<!DOCTYPE html>
<html lang="en">
<head>
<title>cronokirby - Projects</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous"><title>cronokirby - Projects</title>

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="1970-01-01">1970-01-01</time>

<h1>Projects</h1>




</header>

<ul><li>
<p><a href=https://github.com/cronokirby/cait-sith>Cait-Sith</a> <em>2023</em></p>
<ul><li>Cait-Sith is a novel threshold ECDSA protocol (and implementation), which is both simpler and substantially more performant than popular alternatives.
The protocol supports arbitrary numbers of parties and thresholds.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/magikitten>Magikitten</a> <em>2022</em></p>
<ul><li>A system to make public-coin protocols non-interactive, using <a href=https://github.com/cronokirby/meow>Meow</a>.
Inspired by <a href=https://merlin.cool/>Merlin</a>.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/meow>Meow</a> <em>2022</em></p>
<ul><li>This crate is an implementation of <a href=https://strobe.sourceforge.io/specs/>STROBE</a> using KitTen (reduced round <a href=https://keccak.team/keccak.html>Keccak</a>).
STROBE is a framework for symmetric cryptography protocols, similar to
how Noise works for key exchange.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/deevee>Deevee</a> <em>2022</em></p>
<ul><li>An implementation of <a href=https://www.wikiwand.com/en/Designated_verifier_signature>Designated Verifier Signatures</a>.
This is like a normal signature scheme, except that the signer
designates a verifier for each signature.
Only this verifier can validate the signature.
Furthermore, the verifier can forge signatures which designate them.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/boo-hoo>Boo-Hoo</a> <em>2022</em></p>
<ul><li>An implementation of <a href=https://eprint.iacr.org/2016/163>ZKBoo</a>.
This is a library for creating Non-Interactive Zero-Knowledge Proofs
of Knowledge (NIZKPoKs) for arbitary boolean functions.
In other words, given some arbitrary function <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span></span></span></span></span>, and some claimed
output <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0359em;">y</span></span></span></span></span>, you can prove that you know an input <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> such that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.625em;"></span><span class="mord mathnormal" style="margin-right:0.0359em;">y</span></span></span></span></span>,
without revealing what the secret <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> is.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/yao-gc>Yao's Garbled Circuits</a> <em>2022</em></p>
<ul><li>An implementation of <a href=https://www.wikiwand.com/en/Garbled_circuit>Yao's Garbled Circuits</a>.
This is a protocol which lets two parties compute a boolean function
of their private inputs, without revealing those inputs to each other.
This is one of the earliest and simplest two-party MPC protocols.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/seed-split>Seed Split</a> <em>2022</em></p>
<ul><li>A simple tool to split seed phrases (like with Ethereum, Bitcoin, etc.) into
multiple shares. Any threshold of these shares can then be used to recover
the original seed phrase.
A good occasion to implement arithmetic over binary fields from scratch as well.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/sally>Sally</a> <em>2022</em></p>
<ul><li>A simple shell written in C. I implemented basic features like command
execution, output redirection, and piping output between processes.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/wordle>Wordle Solver</a> <em>2022</em></p>
<ul><li>A little solver for the infamous <a href=https://www.powerlanguage.co.uk/wordle/>Wordle</a>
game, as well as a little CLI implementation of the game. Mainly just
a fun weekend project, and a way I consistently beat the game.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/ludus-web>Ludus Web</a> <em>2021</em></p>
<ul><li>A port of my NES emulator to the web, using WASM.
<a href=https://ludus-web.cronokirby.com>Live</a>. Provides a more accessible
interface compared to my old <a href=https://github.com/cronokirby/ludus>ludus</a> project.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/multiset-hash>Multiset Hash</a> <em>2021</em></p>
<ul><li>A simple incremental hash function for multi-sets.
The result of the function depends only on what objects
are passed into the function, and not the order they appear.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/eddo>Eddo</a> <em>2021</em></p>
<ul><li>I wanted to implement Ed25519, so I did that, with
this crate implementing everything from scratch, including
SHA-512.
I also wanted to optimize the implementation, but didn't get around
to that.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/nuntius>Nuntius</a> <em>2021</em></p>
<ul><li>A little CLI tool for E2E encrypted messaging. I implemented
Signal's <a href=https://signal.org/docs/specifications/x3dh/>X3DH</a>
and <a href=https://signal.org/docs/specifications/doubleratchet/>Double Ratchet</a>
in a pretty straightforward way. Unlike Signal, this application
is session based instead of asynchronous, out of simplicity.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/nimotsu>Nimotsu</a> <em>2021</em></p>
<ul><li>A little tool to encrypt files to public key identities, using
<a href=https://tools.ietf.org/html/rfc8031>Curve25519</a>,
<a href=https://github.com/BLAKE3-team/BLAKE3>Blake3</a>, and
<a href=https://tools.ietf.org/html/rfc7539>ChaCha20-Poly1305</a>, all
implemented from scratch.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/saferith>Saferith</a> <em>2021</em></p>
<ul><li>A library providing constant-time Big Number arithmetic, for Go. Essentially,
a replacement for <code>big.Int</code>, suitable for Cryptography.
This was the subject of my <a href=/papers/2021/06/bsc_report.pdf>BSc Project</a>
at EPFL, under the supervision of <a href=https://people.epfl.ch/bryan.ford>Prof. Bryan Ford</a>.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/fractals>Fractals</a> <em>2021</em></p>
<ul><li><a href=https://fractals.cronokirby.com>Live</a>
This is a fun little fractal explorer I made over a few days.
This uses the mandelbrot and julia sets as base fractals, along with
various coloring modes based on iteration or orbit traps.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/enku>Enku</a> <em>2021</em></p>
<ul><li>I was bored one weekend, and decided to implement
<a href=https://tools.ietf.org/html/rfc7539>ChaCha20</a> from scratch
(easier than it sounds) to make a tool for encrypting data.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/haskell-in-haskell>Haskell-in-Haskell</a> <em>2021</em></p>
<ul><li>This is a compiler for a respectable subset of Haskell,
written in Haskell. This features standard data types,
pattern matching, as well as lazy evaluation!
I'm also writing <a href=/series/haskell-in-haskell>an in-depth series</a>
about this compiler</li></ul></li><li>
<p><a href=https://github.com/cronokirby/katex-playground>KaTeX Playground</a> <em>2020</em></p>
<ul><li><a href=https://katex-playground.cronokirby.com>Live</a>
I whipped this up over an afternoon. It's just a little
site letting you write math equations interactively
thanks to <a href=https://katex.org/>KaTeX</a>.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/arbor>Arbor</a> <em>2020</em></p>
<ul><li>This is a simple replacement for the Unix <code>tree program</code>.
This will print out the file system hierarchy in tree form, starting
from a given path. The program comes with configurable options for depth,
Unicode, and color output.</li></ul></li></ul><!--more-->
<ul><li>
<p><a href=https://github.com/cronokirby/conway>Conway</a> <em>2020</em></p>
<ul><li>A simple implementation of <a href=https://www.wikiwand.com/en/Conway%27s_Game_of_Life>the classic Cellular Automaton</a>, as
an interactive graphical application in Haskell.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/reg-viz>Reg Viz</a> <em>2020</em></p>
<ul><li><strong>Reg Viz</strong> is a simple CLI tool taking a regular expression, and outputting a representation
of the NFA / state machine recognizing that language. This is useful to visualize
the correspondance between regular languages and finite state machines.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/mooz>Mooz</a> <em>2020</em></p>
<ul><li>
<p>This is a simple application that lets you start video calls with multiple
people, in a peer 2 peer fashion. Unlike applications like zoom, there's
no central server handling connections.</p>
<p><a href=/posts/simple-webrtc-video-chat>Read More</a></p></li></ul></li><li>
<p><a href=https://github.com/cronokirby/musync>Musync</a> <em>2020</em></p>
<ul><li>
<p>This is similar to <a href=https://github.com/cronokirby/populate>Populate</a>.
This is a program that can clone a music library based on its description. It can download
albums, split them automatically, and add metadata to these songs, like cover art and names.</p>
<p>It uses <code>youtube-dl</code> for the downloading, and <code>ffmpeg</code> for the splitting.</p></li></ul></li><li>
<p><a href=https://github.com/cronokirby/poline>Poline</a> <em>2019</em></p>
<ul><li><strong>Poline</strong> is a little programming language I wrote to learn
about implementing Green Threading. The language
doesn't feature much more than string literals, and mechanisms
for spawning threads and communicating between them.
Green Threads allow many logical threads in a program to
execute on a limited number of actual OS threads. They
can be preempted off if they invoke a blocking operation.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/ginkou>Ginkou</a> <em>2019</em></p>
<ul><li><strong>Ginkou</strong> is a program to build up a corpus of searchable sentences.
<strong>Ginkou</strong> can consume Japanese sentences from the command line, or from a text
file, parse those sentences into words, and then index those sentences for
easy retrieval. Given a word, <strong>Ginkou</strong> can look up sentences containing
that word, even if it's in a different form, such as a conjugated verb.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/persistent-ts>Persistent-ts</a> <em>2019</em></p>
<ul><li>This is a library providing a handful of persistent data structures for Typescript.
This includes immutable collections like linked-lists, and clojure-style vectors.
Persistent data structures are immutable, but can efficiently share data between instances,
and are thus more efficient than a normal copy-on-write collection when working without mutation.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/serve-csv>Serve-csv</a> <em>2019</em></p>
<ul><li>This is a program that can take a folder of CSV files and serve them as a REST API.
The program also uses a JSON file for each file, to specify how each column maps to a JSON
field. The program is written in Go to make use of the built-in HTTP server.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/haze>Haze</a> <em>2019</em></p>
<ul><li><strong>Haze</strong> is a complete bittorrent client, capable of downloading any kind
of torrent found in the wild. Bittorrent is a peer-to-peer protocol, where a client
joins a large swarm of peers in order to download a file of common interest. Haskell was
used in order to help manage the concurrency involved in communicating with a large number of
peers.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/dex>Dex</a> <em>2019</em></p>
<ul><li><a href=https://cronokirby.github.io/dex>Live</a>.
<strong>Dex</strong> is a little frontend app for searching and seeing stats about Pokemon, made with Vue.
The app wraps around the <a href=https://pokeapi.co/>pokeapi</a> REST API for information about each Pokemon.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/ripple>Ripple</a> <em>2019</em></p>
<ul><li><strong>Ripple</strong> is a program implementing a small decentralised chat protocol, written in <em>Go</em>.
The protocol involves participating nodes ferrying messages to eachother in a ring like fashion.
New nodes can join the chat by talking to any of the existing nodes in the swarm. <em>Go</em> is used for
simple networking and concurrency, as well as to provide both a command line, and a graphical terminal interface.
<a href=/posts/notes-on-ripple/>Read More</a></li></ul></li><li>
<p><a href=https://github.com/cronokirby/bittrickle>Huffman-rs</a> <em>2019</em></p>
<ul><li>This is a CLI program using <em>Huffman Coding</em> to compress files. The program is written in <em>Rust</em>
for efficiency.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/bittrickle>Bittrickle</a> <em>2019</em></p>
<ul><li><strong>Bittrickle</strong> is an implementation of Bittorrent's UDP tracker protocol. A tracker keeps
track of peers participating in a bittorrent swarms, sharing files. Peers communicate with
the tracker in order to learn about each other. This implementation uses <em>Rust</em> because of its
built-in UDP networking.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/cauchy>Cauchy</a> <em>2019</em></p>
<ul><li><strong>Cauchy</strong> is a program to generate plots of complex functions, written in <em>Rust</em>
<strong>Cauchy</strong> is hardware-accelerated, using <em>OpenGL</em> to generate the plots using the GPU.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/populate>Populate</a> <em>2018</em></p>
<ul><li>This is a CLI program that can recreate a music library on a new machine by downloading
the files from various sources across the web. The program parses a file
with a hierarchical description of the library to replicate , and reproduces
that structure by consuming the sources described.
The program can also split up larger albums (via FFmpeg) into individual songs if necessary.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/darby>Darby</a> <em>2018</em></p>
<ul><li>This is a CLI program to take a folder of songs and play them in a random order.
SDL's audio subsystem is used to play audio files. This program was built to accompany
<a href=https://github.com/cronokirby/populate>populate</a>, which generates folders filled with songs,
ready for consumption by this program.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/peerbin>Peerbin</a> <em>2018</em></p>
<ul><li><a href=https://cronokirby.github.io/peerbin/#/>Live</a>.
This project provides a version of websites like pastebin, or hastebin, except without
a central server to store the files; instead users send the files to eachother
via <a href=https://webtorrent.io/>webtorrent</a>. <em>Elm</em> is used for the main
UI components, and <em>Javascript</em> to glue this code with the webtorrent part.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/hax>Hax</a> <em>2018</em></p>
<ul><li><strong>Hax</strong> is a bullet hell game, in the same vein as others like <em>Touhou</em> or <em>Ikaruga</em>.
The game is written in Haskell, using SDL for handling the drawing logic. The game
logic benefits greatly from the use of an entity component system for handling the many entities
in the game. <a href=https://hackage.haskell.org/package/apecs>Apecs</a> was used to provide the scaffolding
for this ECS.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/ludus-emu>Ludus</a> <em>2018</em></p>
<ul><li><strong>Ludus</strong> is an emulator for the NES console, written in <em>Rust</em>. The emulator
fully emulates, the core CPU, as well as the PPU and APU, and thus full video
and audio. The emulator also supports a handful of mappers / cartridge types, and thus
many common games such as Mario or Zelda.</li></ul></li><li>
<p><a href=https://github.com/cronokirby/alchemy>Alchemy</a> <em>2018</em></p>
<ul><li><strong>Alchemy</strong> is a library over the API for the chat application
<a href=http://discordapp.com/>Discord</a>. The library integrates over Discord's REST
and Websocket APIs in order to help developers write applications for their chat
servers. <em>Elixir</em> was used in order to have easy access to the concurrency involved
in juggling these various resources.</li></ul></li></ul><section class="footnotes">
<ol>
</ol>
</section>


</body>
</html>