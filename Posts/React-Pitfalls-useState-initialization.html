<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cronokirby - React Pitfalls: useState initialization</title>
<meta name="google-site-verification" content="L52nFdg1z0h1iXWgwFjYNRl14XgaybiiL_UbPpm6-Mc" />
<link rel="canonical" href="https://cronokirby.com/Posts/React-Pitfalls-useState-initialization.html">
<meta property="og:title" content="React Pitfalls: useState initialization">
<meta property="og:url" content="https://cronokirby.com/Posts/React-Pitfalls-useState-initialization.html">
<meta property="og:site_name" content="cronokirby">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Pitfalls: useState initialization">

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" alt="cronokirby" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="2020-01-09">2020-01-09</time>

<h1>React Pitfalls: useState initialization</h1>




<ul class="tags">

  <li class="tag">
    <a href="/tag/frontend/index.html">
    #frontend
    </a>
  </li>

  <li class="tag">
    <a href="/tag/hooks/index.html">
    #hooks
    </a>
  </li>

  <li class="tag">
    <a href="/tag/javascript/index.html">
    #javascript
    </a>
  </li>

  <li class="tag">
    <a href="/tag/react/index.html">
    #react
    </a>
  </li>

</ul>

</header>

<p>This is a quick post about a "gotcha" I encountered recently in a React application.
This involved the use of React's <code>useState</code> hook, which had a subtle difference
between how I thought the hook worked, and how it actually worked.</p><!--more-->
<h1>React Hooks</h1>
<p>If you're already familiar with hooks in React, feel free to skip this section. This
is just a recap for those out of the loop.</p>
<p>Although the first real framework I worked with was <em>Vue</em> (I don't count the one application
I built with JQuery as having used a framework), I've been using <em>React</em> a ton lately, and
it's really been growing on me. There's a lot of advantages to being the "top dog" in the
framework game, and React's popularity gives you access to a large ecosystem, and great
patterns for working on frontend applications.</p>
<p>One thing I really like about React is the recent "hooks" feature.</p>
<p>Previously, react distinguished between <em>function</em> components, which took in some parameters,
called <em>props</em>, and returned some HTML to be rendered, e.g.</p>
<pre><code>function TitleCard({ name }) {
  return <p>Hi my name is {name}</p>;
}</code></pre>
<p>You also had <em>class</em> components, which at first resemble <em>function</em> components:</p>
<pre><code>class TitleCard extends React.Component {
  render() {
    return <p>Hi my name is {this.props.name}</p>;
  }
}</code></pre>
<p>But class components also have a lot of other features in addition to just rendering some data.
Notably, they have access to state:</p>
<pre><code>class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 0};
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={() => this.state.count++}>+</button>
      </div>
    );
  }
}</code></pre>
<p>This component will render a count, and clicking on the button inside that component will increment
the state of that component.</p>
<p>Having a clear way to use state, and other effects like network requests, etc was something missing
from function components. That's where hooks come in. Hooks, in brief, allow you to use
these things in function components.</p>
<p>For example, if we wanted to take our <code>Counter</code> component from the previous example
using a function component with hooks, it'd look like this:</p>
<pre><code>function Counter() {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}</code></pre>
<p>The hook provides us with two values: <code>count</code>, and <code>setCount</code>. The idea is that
<code>count</code> always holds the current value of the state, and <code>setCount</code> allows us to change
this value. The cool thing is that React will always "do the right thing" and magically
update this value and rerender the component if necessary. Neat!</p>
<h1>Rerendering</h1>
<p>One of the core principles when working with React is that the framework strives
to make sure that the values a component logically has is always reflected on screen.
This means that if some value changes, because of a hook, or because one of the props changed,
then a rerender needs to happen to make sure that what's on screen matches what's "in the code".</p>
<p>For example, let's split our counter in two:</p>
<pre><code>function ShowCounter({ count, setCount }) {
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}

function Counter() {
  const [count, setCount] = React.useState(0);
  return <ShowCounter {...{count, setCount}}/>
}</code></pre>
<p>Now the <code>Counter</code> component is the one actually holding the state, and the <code>ShowCounter</code> component
is just a simple function that shows the data given to it. In order to make sure that the user is
always seeing the actual value of the counter, React has to rerender the <code>ShowCounter</code> component
whenever the count passed to it changes value.</p>
<p>This means that React will end up executing the code of the <code>ShowCounter</code> function again. This
is why its important to avoid firing off network requests without <code>useEffect</code> inside
a function component, because you only want to do certain effects when they need to be run,
and not just when the component frivously rerenders.</p>
<h1>State is initialised only once</h1>
<p>Now we come to the main pitfall I want to talk about in this post.</p>
<p>Let's allow the user set a value for the counter:</p>
<pre><code>function Counter({ initial }) {
  const [count, setCount] = React.useState(initial);
  return <ShowCounter {...{count, setCount}}>;
}</code></pre>
<p>Based on our previous model, if <code>initial</code> changes, then the component has to rerender,
and so <code>useState</code> gets called with <code>initial</code>, and so the count becomes <code>initial</code>, right?</p>
<p>Well it turns out that that's not what happens. In fact with the way <code>useState</code> works,
the initial value matters only <strong>the first time a component renders</strong>. After that, it will
preserve the state between renders.</p>
<p>This means that we need to do this instead:</p>
<pre><code>function Counter({ initial }) {
  const [count, setCount] = React.useState(0);
  React.useEffect(() => setCount(initial), [initial]);
  return <ShowCounter {...{count, setCount}}>;
}</code></pre>
<p>We haven't gone over the <code>useEffect</code> hook in detail, but the way it works is that it executes
the callback function only if the values inside the array have changed. So here it will set the counter
to an initial value, but only when the initial value changes. This is the correct way to do
something like this.</p>
<p>Basically, to avoid this pitfall, <strong>you never want to have anything dynamic inside the call to useState</strong>.</p>
<h1>Why is this the case?</h1>
<p>Well, remember how we went over how React "tries to do the right thing". Well, it turns out that
by doing things this way, you actually preserve state between rerenders, which is generally the behavior you want.</p>
<p>For example, let's say we had something like this:</p>
<pre><code>function Counter({ name }) {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <p>{name}</p>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}</code></pre>
<p>Now we're showing a name in addition to the value of the count. We want to rerender if the count or the name
changes, since we want the user to see what the current value actually is, but we don't want the count to be
lost just because the name changed. That's why it makes sense for <code>useState</code> to preserve the
state between rerenders.</p>
<p>It'd require a lot more code to create the behavior of preserving state between rerenders if
it didn't work that way, but it didn't take much effort with <code>useEffect</code> to do what we wanted
in the other case. You generally want to try and make the more common use case easy
with frameworks, don't you.</p>
<h2>Further Reading</h2>
<p><a href=https://reactjs.org/docs/hooks-intro.html>React Hooks</a></p><section class="footnotes">
<ol>
</ol>
</section>


</body>
</html>