<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cronokirby - Constant-Time Big Numbers: An Introduction</title>
<meta name="description" content="Over the past couple months, I've been working on a library for constant-time Big Numbers in Go. I think it's about time that I presented a bit of this work.In">
<meta name="google-site-verification" content="L52nFdg1z0h1iXWgwFjYNRl14XgaybiiL_UbPpm6-Mc" />
<link rel="canonical" href="https://cronokirby.com/Posts/Constant-Time-Big-Numbers-An-Introduction.html">
<meta property="og:title" content="Constant-Time Big Numbers: An Introduction">
<meta property="og:description" content="Over the past couple months, I've been working on a library for constant-time Big Numbers in Go. I think it's about time that I presented a bit of this work.In">
<meta property="og:url" content="https://cronokirby.com/Posts/Constant-Time-Big-Numbers-An-Introduction.html">
<meta property="og:site_name" content="cronokirby">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Constant-Time Big Numbers: An Introduction">
<meta name="twitter:description" content="Over the past couple months, I've been working on a library for constant-time Big Numbers in Go. I think it's about time that I presented a bit of this work.In">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous">

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" alt="cronokirby" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="2021-04-05">2021-04-05</time>

<h1>Constant-Time Big Numbers: An Introduction</h1>




<ul class="tags">

  <li class="tag">
    <a href="/tag/cryptography/index.html">
    #cryptography
    </a>
  </li>

  <li class="tag">
    <a href="/tag/math/index.html">
    #math
    </a>
  </li>

  <li class="tag">
    <a href="/tag/security/index.html">
    #security
    </a>
  </li>

</ul>

</header>

<p>Over the past couple months, I've been working on
<a href=https://github.com/cronokirby/safenum>a library</a>
for constant-time Big Numbers in Go. I think it's about time
that I presented a bit of this work.</p><!--more-->
<p>In this post,
I'll try to explain what exactly this work is about, and why you might
care about it.
This post is intended to be an introduction, and shouldn't require
any background in Cryptography.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
This work is being done as a BSc project at EPFL's <a href=https://www.epfl.ch/labs/dedis/>DEDIS lab</a>,
under the supervision of <a href=https://people.epfl.ch/bryan.ford>Professor Bryan Ford</a>, and would
not be possible without their generous help.</p></blockquote>
<h1>What are Big Numbers?</h1>
<p>As the title suggests, the main concept here is a "Big Number".
Essentially, Big Numbers are nothing more than a way to program with
arbitrarily large integers.</p>
<p>The usual integers you use
in programming have a fixed size. Big Numbers,
on the other hand, have to be dynamically sized.
For example,
a <code>uint64</code> type represents integers from <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> up to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span></span></span>, consuming
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span></span> bits of memory. A Big Natural Number type would instead be able
to represent all numbers in <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></span>. This requires a type that grows
in size to represent larger numbers.</p>
<h2>Big Numbers are familiar</h2>
<p>Big Numbers are actually a familiar concept.
As programmers, we're used to working with fixed size integers.
This is an acquired taste. The natural way you'd think about numbers
isn't constrained in this way.
Most people don't see numbers as having
an arbitrary upper bound; numbers seem to go on
forever:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mn>18446744073709551619</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">0, 1, 2, 3, \ldots, 18446744073709551619, \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.8389em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mord">7</span><span class="mord">3</span><span class="mord">7</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord">5</span><span class="mord">1</span><span class="mord">6</span><span class="mord">1</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span></span></span>
<p>That last number is actually too big to fit over 64 bits, yet it seems
perfectly natural at a first glance.</p>
<p>Essentially, a Big Number library provides a way to work with these
arbitrarily large numbers, providing the common operations, like
addition, multiplication, etc.</p>
<h2>Limited hardware size</h2>
<p>CPUs already include operations for working with fixed size integers.
Nowadays, the most common register size is 64 bits. This means that
operations on integers up to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span></span></span></span></span> are going to be possible in hardware.
However, if you want to work with numbers larger than
64 bits (or whatever your register size happens to be), you'll need
to have an extra software layer implementing this abstraction.</p>
<p>Increasing the size of the CPU's registers can't help
either, since Big Number support requires supporting <em>arbitrarily</em>
large numbers, in general.</p>
<h2>Schoolbook arithmetic</h2>
<p>Not only are Big Numbers familiar to us, but
so are the algorithms manipulating them. To implement operations
on Big Numbers, you start with the pen-and-paper recipes you learned
back in grade-school.</p>
<p>We usually work with numbers in base 10. This means that we interpret a sequence
of digits, such as:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1234</mn></mrow><annotation encoding="application/x-tex">1234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span></span></span></span></span></span>
<p>as the product of each digit with the matching power of 10:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⋅</mo><mn>1000</mn><mo>+</mo><mn>2</mn><mo>⋅</mo><mn>100</mn><mo>+</mo><mn>3</mn><mo>⋅</mo><mn>10</mn><mo>+</mo><mn>4</mn><mo>⋅</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \cdot 1000 + 2 \cdot 100 + 3 \cdot 10 + 4 \cdot 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7278em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></span>
<p>We could emphasize that we're taking powers of 10 here, writing this
number as:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>⋅</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>2</mn><mo>⋅</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>3</mn><mo>⋅</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>4</mn><mo>⋅</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1 \cdot 10^3 + 2 \cdot 10^2 + 3 \cdot 10^1 + 4 \cdot 10^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.9474em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="margin-right:0.05em;top:-3.113em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span>
<p>To add two numbers on pen and paper, you first line them up:</p>
<p>
<img src=../Images/d830d7ac38f5dab8d7063b22ee0eebfc3f20b957c56655b543faa761db867277.png alt= /></p>
<p>and then you add the digits one by one, making sure to keep track of any
carry generated by an addition:</p>
<p>
<img src=../Images/f5080f6f231be22c691b48ca9bd0a3254dba53455076db652871862e106132e3.png alt= /></p>
<p>A carry happens when two digits add up to something greater than 9. For example,
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>7</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">5 + 7 = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7278em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></span>.</p>
<p>Multiplication uses a similar method, where you first multiply one number
by each digit of the other, shifted with the right number of zeros:</p>
<p>
<img src=../Images/6de780e2e85b6bd306ad886088d052a95c73781976d5deec68944e211972d9f2.png alt= /></p>
<p>And then, you add all of these terms together:</p>
<p>
<img src=../Images/071ac8db45ddb0485cd499fe870ede132d3ca4ff1d7d4d5afb9a763dabc3a87b.png alt= /></p>
<p>There are pen-and-paper algorithms
to implement all of the operations on big numbers,
and these serve as the foundation for a library programming these up.</p>
<h2>Digits, bits, and limbs</h2>
<p>Conceptually, I like thinking of big numbers as being large decimal numbers, like:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>43707</mn></mrow><annotation encoding="application/x-tex">43707</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord">3</span><span class="mord">7</span><span class="mord">0</span><span class="mord">7</span></span></span></span></span></span>
<p>We could also express this number in an alternate base. In base 2, this would
be:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1010101010111011</mn></mrow><annotation encoding="application/x-tex">1010101010111011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span></span></span></span></span></span>
<p>In base 16, or hexadecimal, this would be:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>A</mi><mi>B</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AABB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">AA</span><span class="mord mathnormal" style="margin-right:0.0502em;">BB</span></span></span></span></span></span>
<p>In base 10, we usually refer to each individual component of a number as a "digit".
In base 2, these become "bits", and in base 16, I guess you would call these "nibbles"
(being 4 bits long), but I haven't really used that terminology.</p>
<p>In practice, you want to represent your big numbers using a much larger base. Typically,
you'd want each component of your number to use an entire CPU
register. This means representing numbers in base <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span></span>
(where <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> is your register width). With components
this big, we usually call these "limbs": wordplay on "digits", of course.</p>
<p>The foundation for working with Big Numbers (at least in the libraries I know of),
is thus representing them over a list of individual limbs, making a number
over base <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<h1>Big Numbers in Cryptography</h1>
<p>Big Numbers have a natural application when implementing mathematical
algorithms:
you don't want to be constrained by the size of your machine integers. In fact,
because Big Numbers are arguably more natural,
some programming languages use them <em>by default</em>, such as Python.</p>
<p>The application that we're interested in here is <em>Cryptography</em>. Specifically,
<em>public-key Cryptography</em>. The main public-key cryptosystems are actually based
on the application of Big Numbers; at least conceptually.</p>
<h2>RSA</h2>
<p>RSA is perhaps the prototypical example of a public key cryptosystem. I won't be
going over the details of how RSA works; just highlighting a few aspects
about how it uses Big Numbers.</p>
<p>You have a public key <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e, N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)</span></span></span></span></span> with an exponent
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">e \in \{0, \ldots, N - 1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span> and a natural number <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">N \in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></span>. Operations
are done modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> later. Your private key is another exponent <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span>.</p>
<p>Typically, you talk about <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2048</mn></mrow><annotation encoding="application/x-tex">2048</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span></span></span></span></span> or <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4096</mn></mrow><annotation encoding="application/x-tex">4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">9</span><span class="mord">6</span></span></span></span></span> bit RSA. This refers to the size of the
modulus <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>, in bits. Since you're working with numbers that are about
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2048</mn></mrow><annotation encoding="application/x-tex">2048</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span></span></span></span></span> bits long, you need to have support for Big Numbers.</p>
<p>Furthermore, you also need your number library to support <em>modular arithmetic</em>:
the operations making up the RSA system work modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>.</p>
<h2>Elliptic Curves</h2>
<p>With Elliptic Curve Cryptography, you have much more complicated operations as
your foundation. When using a prime field, you bulid up these operations using
arithmetic modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span>, a prime number. Typically, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> is going to be 256 bits or so.
In this case, you can use Big Numbers, along with the modular arithmetic operations.
This only works for <em>prime fields</em> though.
For Galois Fields, you need different
operations: multiplication is no longer just modular arithmetic.</p>
<p>One advantage of ECC over RSA is that the parameters you're working with
can be chosen well in advance. The curve you're using is part of the system itself,
whereas the parameters in RSA are chosen dynamically. Because of this, it's possible
to handcode operations over a given curve using exactly the right sized numbers,
whereas RSA requires using dynamically sized Big Numbers.</p>
<p>Because of this, as well as the relative
smallness of the numbers involved,
most implementations of ECC opt for doing things in a curve specific way,
instead of using a generic Big Number library.
The disadvantage is that this requires much
more effort to adopt a new curve, since you need to write a new implementation
as well.</p>
<h1>Timing attacks</h1>
<p>So far, we've seen what Big Numbers are; now it's time to see what
we mean by "Constant-Time".
The use of Big Numbers in Cryptography
is actually what makes us care about being Constant-Time.</p>
<p>Briefly, you can call a program "Constant-Time" when it isn't
vulnerable to "timing attacks". A timing attack, broadly speaking,
is when observing the timing patterns of some program allows an adversary
to violate the desired security properties of that program.</p>
<p>For example, if an adversary can infer the value of some secret
by observing the execution time of some program using
that secret, then that would constitute a <em>timing attack</em>.</p>
<p>When the timing patterns of some program reveal information,
we call this a <em>timing side-channel</em>.</p>
<h2>A toy example</h2>
<p>Let's take a simple example, to illustrate how this works in practice.</p>
<p>Suppose that you're an adversary who wants to learn the value
of Alice's password. Alice allows you to submit guesses to her server,
which will check your guess, and then tell you whether or not it matches
the password.</p>
<p>
<img src=../Images/35cf8e1e48beda892a9618356ef0524a63ef37ebd2626c2e6bc13f9d659ee7bb.png alt= /></p>
<p>If the password is <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> bits long, then you'll need <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>b</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> guesses
the recover the password, if you just rely on the information provided
by the server.</p>
<p>The naive way of comparing strings is actually vulnerable to a timing attack.
The typical way comparison is implemented compares two strings
character by character, returning <code>false</code> as soon as a mismatch is detected:</p>
<pre><code>var password string

func Eq(guess string) bool {
  if len(guess) != len(password) {
    return false
  }
  for i := 0; i < len(guess); i++ {
    if password[i] != guess[i] {
      return false
    }
  }
  return true
}</code></pre>
<p>This short-circuiting behavior provides us with an additional signal! Not only can
we observe whether or not our guess was correct, but we can also observe <em>how long</em>
it takes the server to respond with an answer. The longer we wait, the more characters
are correct at the start of the string. In fact, we can basically figure
out how many characters at the start of the string were correct:</p>
<p>
<img src=../Images/94e0829e7103129277b7a56375ad09291df583be1e150c6718ba471ddf6b3c7b.png alt= /></p>
<p>Using this information, instead of trying random strings, we can focus on guessing
character by character. At first, none of our characters our correct. Then,
we keep changing the first character of our string, until we get to see that it's correct:</p>
<p>
<img src=../Images/c5bcc53cd932f4ae8bc9aa3f22c46d27ba07d35d6414b9845ed4a8ecb5f169ff.png alt= /></p>
<p>We can keep guessing character by character, since we can observe whether or not
each new character was correct, looking at the timing patterns we observe:</p>
<p>
<img src=../Images/e8be1ffe98fc6287f90e37ed343749c8133f379a8e3e6340de8e5068714e51ea.png alt= /></p>
<p>With this in place, we improve our <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>b</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> bounds all the way to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span>!
Instead of trying all the different combinations, we can instead guess bit
by bit, or character by character.
This is an exponential improvement, and completely destroys the security of this setup.</p>
<h2>More subtle sources</h2>
<p>Keep in mind that this is just an example.
In practice, such a direct guessing game
wouldn't be in place, nor would you use such an obviously broken comparison routine.</p>
<p>In this example, the number of steps our operation take varies
directly, based on its input, because of
how we've structured it. Timing leaks can be more subtle, however.
Code that is ostensibly not variable time can actually hide timing variations
arising from the behavior of the hardware. For example, accessing
memory can leak addresses through cache timing <sup><a href="#fn-2">1</a></sup>, and conditional
statements can leak which branch was chosen, even if both branches take
the same amount of time <sup><a href="#fn-1">2</a></sup>.</p>
<h1>Incomplete mitigations</h1>
<p>If our program has a timing leak, we can first try and hide
this leak, instead of attempting to re-write the program completely.
Unfortunately,
some of the obvious mitigations don't work, and others only work incompletely.</p>
<h2>Sleeping</h2>
<p>When I've explained timing attacks to other people, the first mitigation
they think of is adding
a random amount of waiting to the program. If we take the password
comparison example we used previously, we could make the server sleep
for a random amount of time before returning an answer.</p>
<p>At a first glance, if the timing variation in the comparison is of a few
microseconds, then sleeping around a second or so would seem to completely
mask this signal.</p>
<p>Unfortunately, this doesn't work.</p>
<p>The problem is that we can filter out the noise through statistical analysis.
Let's say that we have our timing variation <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span>, which is constant (given a fixed guess),
and then our random sleep time <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>. The total wait time becomes a random variable:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo>+</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">t + X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.6984em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span></span>
<p>If we take the average, we get:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t + E[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0576em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mclose">]</span></span></span></span></span></span>
<p>since <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span> is a constant. Now, if we simply subtract away <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.0576em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mclose">]</span></span></span></span></span>, we get:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span></span>
<p>which is our signal!</p>
<p>Of course, we can't actually observe the average. What we <em>can</em> do,
on the other hand, is take many samples, and use those to <em>estimate</em>
what the expected value is. Using that information, we can filter
out the noise that's been artificially created, and recover
the timing signal.</p>
<p>Because of this, adding in timing noise can only act as a mitigation,
and not a particularly effective one at that.</p>
<h2>Blinding operations</h2>
<p>Roughly speaking, <em>blinding</em> is a technique where instead of computing
a function <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span></span></span></span></span> directly on some input <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, you first encode the input
differently, in a way that can still be decoded after applying the function.
The idea is that while the function <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.8889em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span></span></span></span></span> may not be constant-time, it will
leak information about the encoded version of <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, but not <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> itself.</p>
<p>One example of this is in RSA. Instead of encrypting a message as
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">m^e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span></span></span></span>, you can instead generate a random nonce, and encrypt
a masked message <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mi>r</mi><msup><mo stretchy="false">)</mo><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">(mr)^e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.0278em;">r</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span></span></span></span>. Exponentiation, unless implemented correctly,
leaks a lot of information about its input. By using blinding,
we hide the input, mitigating this source of information.</p>
<p>These aren't perfect mitigations, for several reasons.
One of these is that the encoding
process itself might leak information through timing side-channels.
Regardless, this remains a popular mitigation for RSA.</p>
<h1>Timing leaks in Go</h1>
<p>Go has a <a href=https://golang.org/pkg/math/big/>big number library</a> as part of its
standard library. While this library has all the operations you might want,
and is quite performant, as far as I can tell. Unfortunately, its operations are
filled with timing leaks: <sup><a href="#fn-3">3</a></sup>.</p>
<p>This is fine, since this API is intended to be a general-purpose Big Number library.
Unfortunately, this library is used for Cryptography not only
outside of Go, but even inside its own standard library. For example, Go's RSA
implementation uses <code>math/big</code>. It does use blinding, so the most obvious
timing attacks are mitigated, but there's likely plenty of vulnerability remaining.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
In some sense, that Go issue describing how its standard library uses
Big Numbers in cryptography, despite having timing vulnerabilities, was the
inception of this project ~ 4 years ago.</p></blockquote>
<p>The timing leaks in <code>math/big</code> come from a two principal sources:
variable-time algorithms, and its representation of numbers.</p>
<h2>Leaky algorithms</h2>
<p>The arithmetic operations in <code>math/big</code> are intended for general-purpose
use, and concentrate on being performant, without regard for
timing leaks. Because of this, many operations take variable execution
paths depending on their input. For example, exponentiation
might conditionally perform a multiplication, based on the bits of
another number. This kind of conditional choice is present
throughout the library, and is a source of timing leaks.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
The leakiness of the exponentiation operation is what encourages Go's
RSA implementation to use <em>blinding</em>.</p></blockquote>
<h2>Unpadded numbers</h2>
<p>Because Big Numbers are dynamically sized, operations can't help
but leak information about the size of their inputs. Unfortunately,
Go makes sure that the size of a number is tightly bound to its actual
value, by removing any unnecessary zeros. For example, if you were working
with numbers modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span>, you might want to always use 3 digits, representing
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span></span> as:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>009</mn></mrow><annotation encoding="application/x-tex">009</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">9</span></span></span></span></span></span>
<p>Go would instead remove this extra padding:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span></span></span>
<p>This means that subsequent operations would leak how small this value is, and we
might be able to distinguish it from larger values.
While seemingly innocuous, this kind of padding information can actually
lead to attacks <sup><a href="#fn-4">4</a></sup>.</p>
<h1>What does constant-time mean?</h1>
<p>So, we've seen what the problem is, but how far can we go in actually solving it?
If Big Numbers are dynamically sized, how can we possibly make our operations constant-time?
What would constant-time even mean in this context?</p>
<p>The key here is to understand that by <em>constant-time</em>, we don't mean that operations
can't take a varying amount of time. Instead, we mean that the timing signal
generated by our operations doesn't leak any <em>secret information</em>.</p>
<h2>True vs announced length</h2>
<p>Big Numbers are indeed dynamically sized. Operations using these numbers will
leak how much space our numbers are taking up.</p>
<p>This seems like a problem at first, until you realize that we can
<strong>lie</strong> about
how big our numbers actually are. Our CPU registers are 64 bits long. A number
like <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span> only takes 2 bits, but the circuitry doesn't take less time to process
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span> compared to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>18446744073709551615</mn></mrow><annotation encoding="application/x-tex">18446744073709551615</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mord">7</span><span class="mord">3</span><span class="mord">7</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord">5</span><span class="mord">1</span><span class="mord">6</span><span class="mord">1</span><span class="mord">5</span></span></span></span></span> just because more of the bits are set
in the latter.</p>
<p>Similarly, we can work with numbers that are padded to be a certain length,
without revealing this padding at all.</p>
<p>It becomes important to distinguish the <em>announced length</em>
of a number, from its <em>true length</em>.
The announced length is the space used by a number, including padding, and will be leaked in operations
using that number. The true length is the minimal number of limbs needed to represent
a number, and should not be leaked.</p>
<p>For example, if we're working modulo a public <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>, which is ~ 2048 bits long, we only
need 2048 bits worth of limbs. We can make sure that all of our values use up that space completely.
Our operations will leak that our numbers are 2048 bits long, but everybody already knows this!
If we have a small number, like <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span>, which doesn't need all that space, we make sure to not
leak the fact that its upper limbs are all <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span>.</p>
<p>Our numbers will be dynamically sized, but should only be sized according to
publicly known information, such as a public modulus, or a protocol driven bitsize.</p>
<h2>Better algorithms</h2>
<p>We also need to make sure that our operations don't leak any information
about the values composing our numbers. This entails
(among other consequences) that we can't look at the bits
of a number to conditionally execute some piece of code, since this would leak
information about the number's actual value.</p>
<p>Essentially, every operation involving our Big Numbers needs to be either amended,
or rethought completely, to make sure that our logic only leaks timing information
based on public information, such as the announced length of our inputs.</p>
<h2>Leaking modulus sizes</h2>
<p>For Cryptography, modular arithmetic is a very common mode of operation. When
working modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>, you only need values up to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, so this dictates
the size of the numbers you'll be working with. Because of this, it's desirable
to make sure that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> itself has no superfluous padding:
your operations have fewer limbs to process, improving performance.</p>
<p>Furthermore,
many algorithms like to make the asssumption that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> has no padding.
Some operations (e.g. modular reduction)
would like to use the most significant bits of <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>,
which ends up leaking the exact bit length of <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
In theory, you could work out the most significant bits of a padded number
without leaking its padding by traversing the entire number, and cleverly
mixing out a final result, through bitwise operations.</p>
<p>I think.</p></blockquote>
<p>Thankfully, this assumption seems to be mostly fine in the common usages of modular
arithmetic in Cryptography.</p>
<p>Usually, your modulus is going to be either a fixed parameter of the protocol,
or part of the public key (like in RSA). In that case, it's obviously fine
to leak its length.</p>
<p>On the other hand, there are some points where the modulus should be kept secret.
For example, to generate an RSA key, you have your modulus <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>p</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">N = pq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0359em;">pq</span></span></span></span></span>, the product
of two primes, and you need to invert <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span> modulo <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p - 1)(q - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0359em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>. Leaking
this value would be bad: learning the factorization of <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>
would allow an adversary to recover your private key.
On the other hand, it's mathematically clear that this value is roughly
the same length as <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>, so leaking its bitsize isn't actually detrimental.</p>
<p>Because of this assumption, it's convenient to truncate the modulus, removing
unnecessary padding.</p>
<h1>Some basic techniques</h1>
<p>So, that's an overview of what we're trying to achieve. Since this
is just an introductory post, I won't be going into the details
of how exactly to accomplish all of this. I can, however,
give a little taster for the kinds of contortions you have to do.</p>
<h2>Some rules of thumb</h2>
<p>Timing attacks can be quite subtle, but I have a working model
of how to avoid them, which is quite pessimistic, but also simple:</p>
<ul><li>Loops leak the number of executions</li></ul>
<pre><code>for i := 0; i < N; i++ {

}</code></pre>
<p>This will leak the value of <code>N</code>.</p>
<ul><li>Conditional statements leak which branch was taken, no matter what</li></ul>
<p>Code like:</p>
<pre><code>if condition {
  foo()
} else {
  bar()
}</code></pre>
<p>will leak the whether or not <code>condition</code> was true or false, regardless
of what code is in either branch.</p>
<ul><li>Accessing memory leaks the index / address accessed</li></ul>
<p>If I do:</p>
<pre><code>array[secret]</code></pre>
<p>this leaks the value of secret.</p>
<p>These are just a few "rules of thumb", but already severely constrain
the kind of code you have to write. You also need to be careful
that the code you write doesn't accidentally get optimized to suddenly
violate these rules either.</p>
<h2>Handling choices</h2>
<p>So, if you can't have a conditional statement based on some secret
value, how do you handle choice? Many algorithms will need to do something
different based on the numbers they're working with.</p>
<p>Fundamentally, the idea is to do <em>both options</em>, and then to select
between them in a constant time way. Instead of having your condition
as a boolean, you could have it as a bitmask, either:</p>
<pre><code>0b1111..</code></pre>
<p>or</p>
<pre><code>0b0000..</code></pre>
<p>depending on the result of the condition.</p>
<p>You can then select between two numbers, through bitwise operations:</p>
<pre><code>func Mux(mask, a, b Word) Word {
  return (mask & a) | (^mask & b)
}</code></pre>
<p>If the mask is all 1s, you select the first input, otherwise, you end
up selecting the second input. So, instead of doing something like:</p>
<pre><code>var x Word
if condition {
  x = foo()
} else {
  x = bar()
}</code></pre>
<p>you'd instead perform both operations, and then select the right one afterwards:</p>
<pre><code>xFoo := foo()
xBar := bar()
x := Mux(condition, xFoo, xBar)</code></pre>
<p>This doesn't have a timing leak anymore, since you can't observe whether or not
<code>foo()</code> or <code>bar()</code> was executed.</p>
<p>This is just a rough idea of how the basic building block works. You also need
to build more complicated operations on type of this, allowing you to conditionally
manipulate entire arrays of numbers, instead of just individual limbs.</p>
<h2>Looping on announced lengths</h2>
<p>Most operations involving big numbers will loop on the length of the numbers
involved. For example, adding two numbers will pair up the limbs composing
each input. We need to make sure that this announced length
is indeed public information, since it gets leaked.</p>
<p>Furthermore, you also can't really loop on other conditions. For example,
you can't make a loop like this:</p>
<pre><code>for a != b {
  doStuff(a, b)
}</code></pre>
<p>Not only does the condition itself leak, which might not be good, but now the
number of steps taken depends on the values of <code>a</code> and <code>b</code>.
(A few operations are actually based on a loop like this.) In each case, you need
to amend things to take a rigid number of steps, based only on the announced
lengths of the inputs, perhaps doing "nothing" for a while.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
Of course, to choose to do "nothing" in a constant-time way, you need to do
something, and then end up not choosing that branch afterwards.</p></blockquote>
<h1>Safenum</h1>
<p>This brings us to the <em>actual work</em>. So far, we've written
<a href=https://github.com/cronokirby/safenum>a library</a>, in Go, providing
an implementation of constant-time Big Numbers (see above for what we mean by "constant-time").</p>
<p>All of the operations necessary for cryptography should be present, and there's only a few hanging
fruit left in terms of obvious performance improvements. Comparing against Go's standard library,
we've gotten performance down from 260x slower, all the way to only 4x slower (comparing
exponentiation with a ~3000 bit modulus). This is actually relatively good, because constant-time
exponentiation is theoretically 2x slower (without windowing), assuming multiplication is just as fast.</p>
<h2>The basic API approach</h2>
<p>The API provides a type representing arbitrary numbers in <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></span>.</p>
<pre><code>type Nat</code></pre>
<p>Each number also carries around an implicit "announced length", which should be public.
The actual value of a number will not be leaked, but the announced length can be.</p>
<p>The announced length of a number is set implicitly based on the operations creating it.</p>
<p>For example, you have:</p>
<pre><code>func (z *Nat) SetBytes([]byte) *Nat</code></pre>
<p>This will set the length of <code>z</code> depending on the length of the slice of bytes.</p>
<p>Another example is addition, where you pass in the number of bits the output should have:</p>
<pre><code>func (z *Nat) Add(a *Nat, b *Nat, capacity uint) *Nat</code></pre>
<p>When doing modular arithmetic, the size of the modulus dictates the size of the output instead:</p>
<pre><code>func (z *Nat) ModAdd(a *Nat, b *Nat, m *Modulus) *Nat</code></pre>
<p>The <code>Modulus</code> type is similar to <code>Nat</code>, except that it's allowed to leak its true length.</p>
<blockquote>
<p>[!note] <strong>Note:</strong>
I've previously written <a href=/notes/2021/01/thoughts-on-big-num-apis/>some notes</a> on alternative
API design, if you want some more information on the tradeoffs involved.</p></blockquote>
<h1>Why Go?</h1>
<p>As mentioned a few times now, the main output of this project is a library
written in Go. The reasons for choosing Go are mainly circumstantial, as opposed
to fundamental technical reasons.</p>
<h2>In a vacuum</h2>
<p>If you were to choose a language for this project, without any concern
over what the likely consumers of the project would be, I think Rust
would likely be the best choice.</p>
<p>I think the reasons for this would be:</p>
<ul><li>Good performance</li><li>Easy control over compiler output</li><li>Portability</li><li>Interoperability with other languages (via C FFI)</li></ul>
<p>Go has the disadvantage of being less portable, and having a few more layers
between you and the assembly output. Having control over this can be important,
since the compiler might violate your assumptions about code organization
with respect to timing leaks.</p>
<p>Some core operations in <code>math/big</code> are actually implemented in assembly,
amounting to a noticeable 50% boost in performance (on my machine).
In Rust, writing these core operations in many platform-specific assembly
files would likely not be necessary. Furthermore, it would be easier
for us to implement new core primitives, rather than being restricted to
the ones already implemented in <code>math/big</code>.</p>
<h2>Being useful</h2>
<p>With all that said, language choices for projects <em>are not</em> made in a vacuum.
Arguably, the most important consideration is who the library is going
to be used by. Most of the potential consumers inside of the DEDIS lab
would like a Go API, which heavily skews things in that direction.</p>
<p>Furthermore, Go's FFI isn't ideal for a library of isolated routines like this.
The problem is that there's a lot of overhead when switching from Go code
over to another language. Paying this overhead for each individual arithmetic
operation in a larger crypto protocol would be too expensive.</p>
<p>This motivates the usage of a library written in Go itself.</p>
<h2>Fitting in <code>math/big</code></h2>
<p>Another goal of the library is to be potentially upstreamable to Go itself,
eventually addressing <sup><a href="#fn-3">3</a></sup>. Because of this, we make use
of the assembly routines already implemented in Go for <code>math/big</code>.
By designing the library with this in mind, we make potentially migrating the work
back into the standard library much easier later on.</p>
<h1>Conclusion</h1>
<p>Hopefully this was at least an interesting overview of the work I'm doing this semester,
which I once again should mention is being done at EPFL's
<a href=https://www.epfl.ch/labs/dedis/>DEDIS lab</a>,
under the supervision of <a href=https://people.epfl.ch/bryan.ford>Professor Bryan Ford</a>,
without whom I would be having substantially less fun right now 8^)</p>
<p>This post was initially intended to be rehashed version of a 7 minute intro talk I gave
a couple weeks ago, but ended up being substantially longer. I think I'll be
making a more in-depth post soon enough, talking about some details on how operations
work. This is also a talk I'll need to be giving in a couple weeks. Once the code has
solidified a bit more, I'd also like to provide a comprehensive post detailing
every single algorithm we end up using.
I don't think there's a complete resource out
there yet, although BearSSL does have
a nice page about this: <sup><a href="#fn-5">5</a></sup>. Unfortunately, this
doesn't cover all the tricks you actually need.</p>
<h1>References</h1>
<p><sup><a href="#fn-1">2</a></sup></p>
<p><sup><a href="#fn-2">1</a></sup></p>
<p><sup><a href="#fn-3">3</a></sup></p>
<p><sup><a href="#fn-4">4</a></sup></p>
<p><sup><a href="#fn-5">5</a></sup></p><section class="footnotes">
<ol>
<li id="fn-2">
<p>[[2] Page, D. ](<a href=https://eprint.iacr.org/2002/169.pdf>https://eprint.iacr.org/2002/169.pdf</a>)</p><section class="footnotes">
<ol>
</ol>
</section>
</li>
<li id="fn-1">
<p>[[1] Acıiçmez, Onur, Çetin Kaya Koç, and Jean-Pierre Seifert. ](<a href=https://doi.org/10.1007/11967668_15>https://doi.org/10.1007/11967668_15</a>)</p><section class="footnotes">
<ol>
</ol>
</section>
</li>
<li id="fn-3">
<p><a href=https://github.com/golang/go/issues/20654>[3] math/big: support for constant-time arithmetic</a></p><section class="footnotes">
<ol>
</ol>
</section>
</li>
<li id="fn-4">
<p><a href=https://raccoon-attack.com/RacoonAttack.pdf>[4] Merget, Robert, Marcus Brinkmann, Nimrod Aviram, Juraj Somorovsky, and Johannes Mittmann. "Raccoon Attack: Finding and Exploiting Most-Significant-Bit-Oracles In", 2019</a></p><section class="footnotes">
<ol>
</ol>
</section>
</li>
<li id="fn-5">
<p><a href=https://www.bearssl.org/bigint.html>[5] BearSSL - Big Integer Design</a></p><section class="footnotes">
<ol>
</ol>
</section>
</li>
</ol>
</section>


</body>
</html>