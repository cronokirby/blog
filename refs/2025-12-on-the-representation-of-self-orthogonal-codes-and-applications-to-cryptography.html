<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cronokirby - (2025-12) On the representation of self-orthogonal codes and applications to cryptography</title>
<meta name="description" content="AbstractThe hull of a linear code is the intersection between the code and its dual.  When the hull is equal to the code (i.e., the code is contained in the dua">
<meta name="google-site-verification" content="L52nFdg1z0h1iXWgwFjYNRl14XgaybiiL_UbPpm6-Mc" />
<link rel="canonical" href="https://cronokirby.com/refs/2025-12-on-the-representation-of-self-orthogonal-codes-and-applications-to-cryptography.html">
<meta property="og:title" content="(2025-12) On the representation of self-orthogonal codes and applications to cryptography">
<meta property="og:description" content="AbstractThe hull of a linear code is the intersection between the code and its dual.  When the hull is equal to the code (i.e., the code is contained in the dua">
<meta property="og:url" content="https://cronokirby.com/refs/2025-12-on-the-representation-of-self-orthogonal-codes-and-applications-to-cryptography.html">
<meta property="og:site_name" content="cronokirby">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="(2025-12) On the representation of self-orthogonal codes and applications to cryptography">
<meta name="twitter:description" content="AbstractThe hull of a linear code is the intersection between the code and its dual.  When the hull is equal to the code (i.e., the code is contained in the dua">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous">

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" alt="cronokirby" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="1970-01-01">1970-01-01</time>

<h1><a href="https://eprint.iacr.org/2025/2279">(2025-12) On the representation of self-orthogonal codes and applications to cryptography</a></h1>


<ul class="authors">

  <li>[[Marco Baldi]]</li>

  <li>[[Rahmi El Mechri]]</li>

  <li>[[Paolo Santini]]</li>

  <li>[[Riccardo Schiavoni]]</li>

</ul>


<div class="published">2025-12-18</div>


<ul class="tags">

  <li class="tag">
    <a href="/tag/cryptography/index.html">
    #cryptography
    </a>
  </li>

  <li class="tag">
    <a href="/tag/paper/index.html">
    #paper
    </a>
  </li>

</ul>

</header>

<h1>Abstract</h1>
<blockquote>
<p>The hull of a linear code is the intersection between the code and its dual.
When the hull is equal to the code (i.e., the code is contained in the dual), the code is called self-orthogonal (or weakly self-dual); if, moreover, the code is equal to its dual, then we speak of a self-dual code.
For problems such as the Permutation Equivalence Problem (PEP) and (special instances of) the Lattice Isomorphism Problem (LIP) over <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0359em;">q</span></span></span></span></span>-ary lattices, codes with a sufficiently large hull provide hard-to-solve instances.
In this paper we describe a technique to compress the representation of a self-orthogonal code.
Namely, we propose an efficient compression (and decompression) technique that allows representing the generator matrix of a self-orthogonal code with slightly more than <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>−</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">k(n-k)-\binom{k+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.0315em;">k</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0315em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2801em;vertical-align:-0.35em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9301em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0315em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span> finite field elements.
The rationale consists in exploiting the relationships deriving from self-orthogonality to reconstruct part of the generator matrix entries from the others, thus reducing the amount of entries one needs to uniquely represent the code.
For instance, for self-dual codes, this almost halves the amount of finite field elements required to represent the code.
We first present a basic version of our algorithm and show that it runs in polynomial time and, moreover, its communication cost asymptotically approaches the lower bound set by Shannon's source coding theorem.
Then, we provide an improved version which reduces both the size of the representation and the time complexity, essentially making the representation technique as costly as Gaussian elimination.
As concrete applications, we show that our technique can be used to reduce the public key size in cryptosystems based on PEP such as LESS and SPECK (achieving approximately a 50% reduction in the public key size), as well as in the Updatable Public Key Encryption Scheme recently proposed by Albrecht, Benčina and Lai, which is based on LIP.</p></blockquote><section class="footnotes">
<ol>
</ol>
</section>


</body>
</html>