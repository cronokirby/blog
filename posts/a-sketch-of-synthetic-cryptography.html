<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>cronokirby - A Sketch of Synthetic Cryptography</title>
<meta name="description" content="This is a brief post sketching out a synthetic style of cryptography. In this style, one doesn't appeal to any kind of complexity theory, probability, or even a">
<meta name="google-site-verification" content="L52nFdg1z0h1iXWgwFjYNRl14XgaybiiL_UbPpm6-Mc" />
<link rel="canonical" href="https://cronokirby.com/posts/a-sketch-of-synthetic-cryptography.html">
<meta property="og:title" content="A Sketch of Synthetic Cryptography">
<meta property="og:description" content="This is a brief post sketching out a synthetic style of cryptography. In this style, one doesn't appeal to any kind of complexity theory, probability, or even a">
<meta property="og:url" content="https://cronokirby.com/posts/a-sketch-of-synthetic-cryptography.html">
<meta property="og:site_name" content="cronokirby">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Sketch of Synthetic Cryptography">
<meta name="twitter:description" content="This is a brief post sketching out a synthetic style of cryptography. In this style, one doesn't appeal to any kind of complexity theory, probability, or even a">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous">

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" alt="cronokirby" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="2023-06-22">2023-06-22</time>

<h1>A Sketch of Synthetic Cryptography</h1>




<ul class="tags">

  <li class="tag">
    <a href="/tag/category-theory/index.html">
    #category-theory
    </a>
  </li>

  <li class="tag">
    <a href="/tag/cryptography/index.html">
    #cryptography
    </a>
  </li>

  <li class="tag">
    <a href="/tag/foundations/index.html">
    #foundations
    </a>
  </li>

</ul>

</header>

<p>This is a brief post sketching out a synthetic style of cryptography.
In this style, one doesn't appeal to any kind of complexity theory,
probability, or even adversary.</p><!--more-->
<p>Instead, one has rules for considering two "games" to be equal,
and applies these at a very granular level.
Of course, one can interpret these rules in a concrete model.
All of the examples in this post should work in the standard
asymptotic model.
In fact, I've tried to structure things so that concrete bounds are easily
derivable, if you care about that kind of thing.</p>
<p>This post is a very brief tour of the important topics one might
cover in a course on cryptography.
Namely, we see:</p>
<ul><li>dealing with randomness and guessing in this framework,</li><li>symmetric encryption security,</li><li>pseudo-random functions,</li><li>properties of random functions,</li><li>public key encryption,</li><li>the KEM-DEM paradigm for public key encryption,</li><li>constructing a CPA secure KEM from groups, in the random oracle model.</li></ul>
<p>Hopefully this tasting platter gives you a good idea
of what proofs in this style can look like.</p>
<h1>String Diagrams</h1>
<p>To start, we'll first go over the general rules for manipulating diagrams
representing cryptographic games.
This presentation tries to be intuitive rather than overly formal,
so the precise definition or rules are less important than developing
a "feel" for how to play with the diagrams.
We leave a formal presentation of string diagrams in general
to other resources, such as [^PZ23].</p>
<p>Our starting point will be a "process":</p>
<p>
<img src=../Images/eb186bdbf07cebfec22b297d336faf92cd85dbb4fa953633389710a01c7e50c9.png alt= /></p>
<p>In other frameworks, one might call this a cryptographic game,
or a package.
Because our level of granularity is very fine, we simply refer to it
as a process instead.
A process is connected to several input wires, on the left,
and several output wires, on the right.
Each of these wires has a type, giving the process as a whole
a signature, which we'd write in this case as:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><msub><mi>X</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>X</mi><mn>2</mn></msub><mo>⊗</mo><msub><mi>X</mi><mn>3</mn></msub><mo>→</mo><msub><mi>Y</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A : X_1 \otimes X_2 \otimes X_3 \to Y_1 \otimes Y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.8333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;top:-2.55em;margin-left:-0.0785em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.8333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.2222em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.2222em;top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>As this notation might suggest, we can think of a process
as a kind of function, taking in some inputs,
and producing some outputs.</p>
<p>Some important differences between a process and a function are:</p>
<ul><li>A process is <em>randomized</em>.</li><li>A process may not use all of its inputs.</li><li>A process may produce some outputs before others.</li></ul>
<p>The last two points are actually quite important.
Another way to think of them is that wires connected
to a process are either "dead", carrying a dummy value <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">⊥</span></span></span></span></span>
indicating this, or "alive", then carrying a value
of the type that wire is.
A wire can change its value from dead to alive,
but once it is alive, it will never change its value again.</p>
<p>Each output wire has a set of input wires it depends
on, and as soon as all of these wires are alive,
the process will produce an output on <em>this</em> wire
in particular, in a randomized way.
Any given output wire may have their value
ready before other output wires.</p>
<p>If this doesn't make complete sense in the abstract, that's fine,
we'll be highlighting how this point shows up as necessary.</p>
<p>In the next subsections, we look at various rules for gluing
processes together, and manipulating diagrams of connected processes.</p>
<h3>Shorthand for Products</h3>
<p>The type <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \otimes B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span></span></span></span></span> denotes the type of "both <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> and <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span></span></span></span></span>".
Because of this, we can treat two wires as one, like this:

<img src=../Images/526251c8e39a14cbfce6f9c2793c008e36e51462f95aea13baf2c3cfd0421d88.png alt= />
This just a notational convenience,
the meaning of the process is otherwise the same.</p>
<p>Sometimes processes will consume the wires split, and other times,
some processes will be written with the wires joined.
To convert between the two, we use the following bits of notation:

<img src=../Images/ba59b3dd581cb307187ab741523b3d222a1834cce9090bb0e290049a6472da1f.png alt= />
The first takes multiple wires, and combines them into one
wire with <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊗</span></span></span></span></span>.
The latter does the opposite, taking one wire with some types connected
by <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.6667em;"></span><span class="mord">⊗</span></span></span></span></span>, and separates them out into parts.
In isolation, these might be a bit ambiguous, but they
usually become clear in context.</p>
<p>As a shorthand, we also write <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> to denote <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>A</mi><mo>⊗</mo><mo>…</mo><mo>⊗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \otimes A \otimes \ldots \otimes A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>,
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> times.</p>
<h3>Back-to-Back</h3>
<p>The first way to connect two processes is via their wires:</p>
<p>
<img src=../Images/840c47ba4bdf79ff8e4ce6cc369f2602657faef2c7e5bcf0581a32eb586fc901.png alt= /></p>
<p>In terms of the underlying math,
given processes <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">A : X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span></span></span></span></span>, and <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">B : Y \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">Z</span></span></span></span></span>, we can define
the process:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊳</mo><mi>B</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">A \rhd B : X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0352em;height:0.7185em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin amsrm">⊳</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">Z</span></span></span></span></span></span>
<p>One crucial aspect of composition is that the order in which we compose
doesn't matter:</p>
<p>
<img src=../Images/65825342fa771609a467db54ba7520c84f6dd20f00967daba914aa4d4727c184.png alt= /></p>
<p>This is also suggested by the notation we use.
With our notation, it's not easy to distinguish between the two orders
of composing, which is fine, since the order doesn't matter!
This is the first in an instance of many notational choices in our
diagram system which reflect equivalences in the underlying processes.</p>
<h3>Side-by-Side</h3>
<p>The other way to compose protocols is via <em>tensoring</em>, or, side-by-side:

<img src=../Images/ba1e43f71a4c73831f93c6e60fddddd8fca5d228b54a9606ea4b5e1713e17931.png alt= />
In terms of the math, given
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><msub><mi>X</mi><mn>1</mn></msub><mo>→</mo><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A : X_1 \to Y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.0785em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.2222em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>:</mo><msub><mi>X</mi><mn>2</mn></msub><mo>→</mo><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B : X_2 \to Y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.8333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:-0.0785em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:-0.2222em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we write:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi><mo>:</mo><msub><mi>X</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>X</mi><mn>2</mn></msub><mo>→</mo><msub><mi>Y</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A \otimes B : X_1 \otimes X_2 \to Y_1 \otimes Y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.0785em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.0785em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.8333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-left:-0.2222em;margin-right:0.05em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.8333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:-0.2222em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>It's important to note that the point about output wires being
able to have values independently of each-other is important.
The output on <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>'s section of the combined process
will be ready as soon as the input on <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span> is,
and ditto for <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span></span></span></span></span>.
Each half doesn't need to "wait" for the other half to be ready.</p>
<p>As with composition, the order in which we tensor doesn't matter,
as the notation suggests:</p>
<p>
<img src=../Images/7fb56224ec84147355be1e2752c57eb072261065e22cefb483de2c057d97fa1d.png alt= /></p>
<h3>Interchange</h3>
<p>Composition and tensoring also play very nicely with eachother.
If you have processes <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A, B, C, D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.8778em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">D</span></span></span></span></span>, boxed up like this:

<img src=../Images/8ed30ca3f6fa8ae81eb33b110fd9b5a8e76d93cd7a8c08a4db5b53297c3fad7e.png alt= />
Then there are two ways of looking at this diagram:

<img src=../Images/5a33f649a29ace683013c59b54247d22c069a1f6c8a0ac184368c148e5cbddc5.png alt= />
In the first way, you tensor first, then compose,
in the second way, you compose first, and then tensor.</p>
<p>The order you do these operations does not matter!
Once again, the notation expresses this fact by not reflecting
any differences in terms of the diagram.</p>
<h3>Sliding</h3>
<p>Next, we introduce little gadgets we can use.
The first of these gadgets is "<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>", a process
which simply returns its input:

<img src=../Images/e8d3da8c9d69e5bb806d82f36577ee2da04b63c225bf35a5c203990bddf47ca9.png alt= />
In math, we have <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">1_X : X \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="margin-left:0em;top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0785em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span> (for any type <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>).</p>
<p>The defining property is that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> composed with any other process,
in front, or in back, is just the same process:

<img src=../Images/d68e8975cfa82ad3105468909bc7917b52fe48342b107b75e752a354d47f5925.png alt= /></p>
<p>Combining this property with that of interchange allows
us to "slide" processes along wires:</p>
<p>
<img src=../Images/efe035ffc34e65259e2981530a284d51e874ced62f7112775156213219881fd6.png alt= /></p>
<h3>Swapping</h3>
<p>Next, we introduce another gadget, which is a process which
swaps its inputs:

<img src=../Images/8702eb175c3aa98f7c1fe772c001d25f01a968b1dc463cc9021706ee8f5afa09.png alt= />
Once again, the outputs here will be ready as soon as the corresponding
input is, without needing to wait for the other,
just as in an electrical circuit, or something like that.</p>
<p>One key property of swapping is that doing it twice is the same
as not swapping:

<img src=../Images/04454a08bd55b47e3321ba96f41c15e515f096aec03db0cb8358822a312c2cd2.png alt= />
(As a consequence, swapping an even number of times does nothing.)</p>
<h3>Backwards and Forwards</h3>
<p>Next, we also consider processes which may also have inputs
on the right, and outputs on the left:

<img src=../Images/7a627e1deef92e98df0006b680af1c22087e1823b299741b29b475cceca2f650.png alt= />
Thus, on certain wires, information flows "backwards".
To make this clear, we make sure to write the direction on those arrows.</p>
<p>There are two fundamental gadgets which reverse the flow of arrows:

<img src=../Images/64fe8e619b0434cd701e0d912b6e2137ef3f842946483f92f06d6fcdc195a5fe.png alt= />
Intuitively, these just take the information on one wire and
put it on another, flowing in the other direction.</p>
<p>As one might expect, these gadgets satisfy a natural law:

<img src=../Images/58aae8fbcaa68f22e496aad634b4f8224c6795ef5865e8bbb42f12a803a14494.png alt= />
In other words, changing the direction of flow twice does nothing.</p>
<h3>Copying and Deleting</h3>
<p>The final gadgets we'll look at our processes which copy
and discard information:</p>
<p>
<img src=../Images/d4446542770c16d753f741e8f1962d4b7be92bbec716c48e8a9a8c09453ebb62.png alt= /></p>
<p>We can think of the first process as copying its input,
and outputting it on two wires,
and the second process as ignoring its input,
producing no output.</p>
<p>These satisfy a few properties.</p>
<p>First, when we copy twice to get three outputs,
the order we do this in does not matter:

<img src=../Images/4469e9f2d96cf0ee36801fbdbf47066ac737d31c0682b373ed02537be9a6fe8d.png alt= />
Second, when we copy, swapping the two outputs does nothing:

<img src=../Images/0f3f74b435c9b94aec2625ed9d04c110e1d3ff60ce15b1677f4b1ee2f8f18ef6.png alt= />
Finally, if we copy and discard either output,
the end result is the same as just returning the input:

<img src=../Images/d8a18e9bf50dacd7906e55273271e9eeffd4c0136b5dcf12c8aef41fd200f696.png alt= /></p>
<h3>Summary</h3>
<p>To summarize, processes are boxes, with inputs and outputs,
representing a randomized machine which can write values,
once, to its output wires, by reacting to inputs
provides on its input wires.</p>
<p>Inputs and outputs can appear on other side,
and we can move boxes around freely, as long as the connections
between inputs and outputs are preserved.</p>
<p>As an example of this kind of easy manipulation, the following
two diagrams represent the same process:

<img src=../Images/b17efa96e190352d5be67d420fb4030f13103e2a5c4756b48d902ca51edca527.png alt= /></p>
<p>The notation we've chosen is such that it reflects this kind of equality
very easily, freeing us to not really have to think all that much
about these low level details.</p>
<h1>Properties and Rewrites</h1>
<p>One crucial aspect of the calculus we're developing is that if
a process is equal to another in isolation,
then it will also allow us to substitute that process
for the other in an arbitrary context:

<img src=../Images/4c2494724b26541ef61e4f78b6379610012c0bdd89b828eb7db80d7fe0ab554c.png alt= />
For the rules we've seen so far, we can apply them without
really caring about how many times we do so,
and assuming them to be "true".</p>
<p>In cryptography, often times we have rules that we want to play
around with, but that we don't assume to be absolutely true.
Rather, we care about what rules can be deduced from other rules.
For example, if some problem (e.g. RSA) is hard,
then we can build secure public key encryption.</p>
<p>In these deductions, we also care how many times we use a given
assumption.
This allows us to work backwards, and figure
out what parameters we need to use in the assumptions
to get enough security in the deductions.</p>
<p>So, to do so, we define the notion of a "property",
which is just a named rule.</p>
<p>As an example, consider the following property,
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>AB</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{AB}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">A</span><span class="mord">B</span></span><span class="mclose">]</span></span></span></span></span>:

<img src=../Images/f41f6472fe20dea46b6c1a5bd7cde660d322f9bedec19956198c974970ee23ae.png alt= /></p>
<p>We also have deductions, which are of the form:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mn>1</mn></msub><mo>×</mo><msub><mi mathvariant="normal">Π</mi><mn>2</mn></msub><mo>×</mo><mo>…</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi_1 \times \Pi_2 \times \ldots \multimap \Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:0em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5499em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span></span></span>
<p>The rule is that each assumed property on the left can only be used a single time in the deduction.
As a shorthand, we write <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Π</mi><mi>n</mi></msup><mo>:</mo><mo>=</mo><mi mathvariant="normal">Π</mi><mo>×</mo><mo>…</mo><mo>×</mo><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi^n := \Pi \times \ldots \times \Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord">Π</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span></span>, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> times.</p>
<p>As an example deduction,
consider <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Example</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Example}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">E</span><span class="mord">x</span><span class="mord">a</span><span class="mord">m</span><span class="mord">p</span><span class="mord">l</span><span class="mord">e</span></span><span class="mclose">]</span></span></span></span></span>, defined via:

<img src=../Images/fd3ea6b375c7c662e1cdefb948d838cc08ec72da5248c9509ea99ae4b825b189.png alt= /></p>
<p>The following deduction holds:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>AB</mtext><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Example</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{AB}]^2 \multimap \Pi[\text{Example}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">A</span><span class="mord">B</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">E</span><span class="mord">x</span><span class="mord">a</span><span class="mord">m</span><span class="mord">p</span><span class="mord">l</span><span class="mord">e</span></span><span class="mclose">]</span></span></span></span></span></span>
<p>As demonstrated by the following proof:

<img src=../Images/53173d2fd6f2b3b7819c84bf1ef7b45913b10cea14061b72f24cfb5b7acf00dd.png alt= />
We use <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\epsilon_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.15em;height:0.5806em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;top:-2.55em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> to denote which assumption we use, and
we do indeed use it (at most) twice.
(Another convention we use is that green is used to highlight
changes we've made, which has no impact on the actual semantics
of a diagram).</p>
<h1>Booleans</h1>
<p>Now, we move from a very abstract context, and towards actual
concrete types that exist in cryptography.</p>
<p>The first such type we look at is that of <em>booleans</em>, or
the set <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span>, also written <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">01</mtext></mrow><annotation encoding="application/x-tex">\texttt{01}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord text"><span class="mord texttt">01</span></span></span></span></span></span> for convenience.</p>
<p>We define booleans via their effect on a selector function "<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose">?</span></span></span></span></span>":

<img src=../Images/03b4e4e9631bdbfb5d3b16e3ad43cb660ad2d75e2ee4dbb61d26a605215dd8ee.png alt= />
This function takes a condition, in its first input,
which it uses to select one of two inputs.
It takes the top one when the condition is true, and the bottom
one when the condition is false.</p>
<h2>Gates</h2>
<p>The selector functions are sufficient to define logic gates.</p>
<p>For example, here's negation (<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span></span></span></span></span>):

<img src=../Images/74c1f9cf918c52af6f4da99f5e1a66fce6d56e3108aa2a30d53c25acd6b373d1.png alt= /></p>
<p>And, here's logical and (<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span></span>):

<img src=../Images/3372fb62c5f5dd16cf3962fac62ffcaf610ddd899f9fb43691067c5185363983.png alt= /></p>
<p>Naturally, we can then define all other logical operators
by combining these two operations.</p>
<p>We also define natural multivariate versions of these gates,
taking more than one input, by chaining them together.
E.g. the and of several variables is <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∧</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>∧</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">((x_1 \land x_2) \land x_3) \land \ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:0em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span></span>.</p>
<h2>Equalities</h2>
<p>Booleans can be produced by different processes,
but usually a boolean is produced as the result of some kind of comparison.
One very important kind of comparison we'll be needing is that of <em>equality</em>.</p>
<p>Some types are able to be compared for equality, in which case
the operator "<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span></span></span></span></span>" is defined:

<img src=../Images/c8049eb99a592863a27277e92f8b4ab45575e767ab9ffe3aeb9f6c0bc8bd053f.png alt= /></p>
<p>Many times, we'll want to compare multiple things
against a single thing, which we define via the operator "<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">=_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="margin-right:0.05em;margin-left:0em;top:-2.55em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>":

<img src=../Images/250178a70524b0377c74cf228490bd2d56c885e8431506303d3e16625b14bff4.png alt= /></p>
<p>This is also our first instance of defining a construction by induction.
We define the general case for <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> inputs by looking
at the case with <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> an inputs, and then at the case where
we have one additional input.</p>
<p>Finally, the last kind of equality we have will check
if any among a list of values is equal to another, via "<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mi mathvariant="normal">∃</mi></msub></mrow><annotation encoding="application/x-tex">=_\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>":

<img src=../Images/a0b112a689f1881398e5076cab6df226745ecc0bc4b5f81e8b051c20878bb2b9.png alt= />
Another way of looking at it is that this operation checks
if there exists a collision between the variables.
The inductive definition says that a single variable
has no collisions,
and that checking a collision for <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1 + N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> variables
amounts to checking if any of the <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> are equal to the first one,
or collide amongst themselves.</p>
<h3>Equality of Copied Values</h3>
<p>Another natural property of equality is that comparing duplicated
elements for equality will always return true:

<img src=../Images/29dc370a9195880a20975c6ade41c7da91a843aa81c3c594097b37d2741ed8e8.png alt= /></p>
<h1>Randomness</h1>
<p>What differentiates cryptography from other fields is ultimately that of
randomness.
In this section we define some basic properties
of randomness, which will be the foundation for the rest of the
schemes we see in this post.</p>
<p>Some types are said to be <em>sampleable</em>, when there exists
a process of the form:

<img src=../Images/ec837c72c326aef3758ac0008245ed0dc66d5741fe8d8fc8fe23b0a12b7e2adb.png alt= />
This process should be understood as being a way of sampling a uniform
value of this type.</p>
<p>Furthermore, some types have some addition operation, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span></span>,
which as one might expect with randomness:

<img src=../Images/925d4ffc677eecbf652612b1fae06dc7b808085028f9b976ea397983952e961c.png alt= />
In other words, a random value added to any value is the same
as a fresh random value.</p>
<h2>Guessing</h2>
<p>For some types, it's difficult to guess a value sampled at random,
without first seeing that value.</p>
<h3>Barriers</h3>
<p>In order to formalize "without first seeing", we introduce the notion of barriers:

<img src=../Images/aa8ef5188c277a6ae3dcb62327b19773ff36aab426aec274358462b670ae25fa.png alt= />
A barrier is simply a process, denoted by this bar, which
waits for <em>all</em> of its inputs before returning them on its outputs.</p>
<p>Here are some properties of barriers:</p>
<p>
<img src=../Images/9bf7932ea8b95c0f96a4e6d1566d961f582f2605e9846d2261469ad37709f22b.png alt= /></p>
<p>Intuitively, these capture the fact that a barrier can't be "crossed",
unlike a standard wire, but that a barrier only cares about the "dependencies"
of its wires.</p>
<h3>Back to Guessing</h3>
<p>Now, having defined barriers, let's go back to the task we had before,
which is that of defining what it means to have values
which are hard to "guess" if sampled at random.
We call such types <em>large</em>,
as defined by the following property:</p>
<p><strong>Property:</strong> For a type <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Guess}(X)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mclose">)]</span></span></span></span></span> is defined via:

<img src=../Images/8464d4aad8a68a4e42c9ff24d966c013016e444ce61799db892d0a170a0f35bf.png alt= /></p>
<p><span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">□</mi></mrow><annotation encoding="application/x-tex">\square</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">□</span></span></span></span></span></p>
<p>In other words, for large types, this property will hold.
We usually consider it as an explicit assumption though,
allowing us to keep track of how many times the assumption
is used, and thus choosing
a concrete size for the type for it to be large enough
in the context of a given system.</p>
<p>The barrier here is crucial, otherwise one could show this property
to never hold, by copying the random value
and using it as the guess.
The barrier prevents this, by forcing the guess to be chosen
before the random value is seen.</p>
<h3>Implied Equalities</h3>
<p>We've shown a basic guessing property for a simple equality,
but what can we say about guessing properties
for more complicated equalities?</p>
<p>First, for <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>=</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">=_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5169em;vertical-align:-0.15em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, we can set up the property <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{MultiGuess}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>,
saying that guessing is hard, even with multiple guesses:

<img src=../Images/019d6ea2d5499bf7cd6d2f07a5760cf701467e40c267f81febea71c61716fc92.png alt= /></p>
<p>As one might expect, if guessing with one try is hard,
so is it with multiple tries.</p>
<p><strong>Claim:</strong></p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><msup><mo stretchy="false">]</mo><mi>N</mi></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Guess}]^N \multimap \Pi[\text{MultiGuess}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1.1413em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="margin-right:0.05em;top:-3.113em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></span>
<p><strong>Proof:</strong></p>
<p>We proceed by induction.</p>
<p>First, we prove that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Guess}] \multimap \Pi[\text{MultiGuess}(1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/8ac4b003ae24948e852245899bc9b544149b6026779ec362a9e5a8e3535e0b7c.png alt= /></p>
<p>Next, we prove that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><mo stretchy="false">]</mo><mo>⊗</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><msup><mo stretchy="false">]</mo><mi>N</mi></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Guess}] \otimes \Pi[\text{Guess}]^N \multimap \Pi[\text{MultiGuess}(1 + N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/5c31cecb7d2f3f7f058306ec71b8e96781e4f1ba6511757c01e2be8f063fb5df.png alt= /></p>
<p><span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
<p>This property will be useful in many contexts where we want
to use a random value more than once.</p>
<h2>Random Functions</h2>
<p>Next, we develop a little gadget we'll be using a few times throughout this
post: random functions.
Random functions are useful to define the random oracle model of security,
and to define pseudo-random functions, which we'll use for encryption.</p>
<p>Mathematically, a random function <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.8889em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span></span></span></span></span>
is like sampling a value from that set of functions randomly.
The outputs of <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span></span></span></span></span> will be random, subject to the condition
that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo rspace="0em" lspace="0em" mathvariant="normal">′</mo></msup><mspace width="0.2778em"/><mo>⟹</mo><mspace width="0.2778em"/><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mo rspace="0em" mathvariant="normal" lspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = x&#x27; \implies f(x) = f(x&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7759em;vertical-align:-0.024em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1076em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</p>
<p>This perspective is a bit cumbersome in that it doesn't give us an easy
algorithmic recipe to construct such a random function.
We need a succinct way to do that.
A useful perspective here is that we can look at making a random
function a lazy mapping.
Each time we produce an output, we check if the input has been
seen before,
in which case we use a previous output,
otherwise we generate a fresh random output.</p>
<p>This leads us to the following definition of a random function
over <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> inputs, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span></span>:

<img src=../Images/59b26259262afb65db665b85077bd51e9077a931b5cfee331fe96f1dd0efcc10.png alt= />
In other words, the first output will always be random,
and the subsequent outcomes will use previous outputs
if they match.</p>
<h3>Random Functions on Random Inputs</h3>
<p>The outputs of a random function are basically random,
except if the inputs have collisions.
If the inputs are random, then collisions will be unlikely,
as the following property,<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\rho\text{Rand}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>, claims:

<img src=../Images/a99c98e67ac3fbb6ee1bb3ed7a32e0e265fd1461e9cdad26f358dc5964aee357.png alt= /></p>
<p>This claim can be proven for large types.</p>
<p><strong>Claim:</strong>
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⨂</mo><mrow><mi>i</mi><mo>=</mo><mi>N</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\bigotimes_{i = N,\ldots,1}\Pi[\text{MultiGuess}(i)] \multimap \Pi[\rho\text{Rand}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">⨂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="margin-left:0em;margin-right:0.05em;top:-2.4003em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span><span class="mpunct mtight">,</span><span class="minner mtight">…</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></p>
<p><strong>Proof:</strong></p>
<p>By induction.</p>
<p><span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{MultiGuess}(1)] \multimap \Pi[\rho\text{Rand}(1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/743ef4856a3b147de1e1c43f1cd7b79ab4dd3192f02b5d9522f0812562b85cc1.png alt= /></p>
<p><span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊗</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{MultiGuess}(1 + N)] \otimes \Pi[\rho\text{Rand}(N)] \multimap \Pi[\rho\text{Rand}(1 + N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/24334df85dcc95ef07d1e06759f355cdbafdd958df2482fa7d414750636fcfea.png alt= /></p>
<p><span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
<p>If we combine this with what we know about <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>MultiGuess</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{MultiGuess}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>,
we get that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Guess</mtext><msup><mo stretchy="false">]</mo><msup><mi>N</mi><mn>2</mn></msup></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mi>ρ</mi><mtext>Rand</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Guess}]^{N^2} \multimap \Pi[\rho\text{Rand}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2369em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">G</span><span class="mord">u</span><span class="mord">e</span><span class="mord">s</span><span class="mord">s</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord mathnormal">ρ</span><span class="mord text"><span class="mord">R</span><span class="mord">a</span><span class="mord">n</span><span class="mord">d</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>.</p>
<p>This is a very useful property, as it shows that applying
a random function to random inputs produces completely
independent random outputs as well.</p>
<h1>Encryption</h1>
<p>Next, we turn our eyes towards symmetric-key encryption.
In this kind of encryption, both the sender and the receiver
share a random value: the key.
Using the key, there's an algorithm to encrypt a message,
producing a ciphertext.
Given a ciphertext, one can decrypt it using the key to recover
the message.
For security, one shouldn't be able to learn any information
about the message just by looking at the ciphertext.</p>
<p>More formally, an encryption scheme is a randomized function:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>K</mi><mo>⊗</mo><mi>M</mi><mover><mo stretchy="true" minsize="1.75em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi mathvariant="normal">$</mi></mpadded></mover><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E : K \otimes M \xrightarrow{\$} \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0576em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.158em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.147em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight">$</span></span></span></span><span style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="min-width:1.469em;height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" preserveAspectRatio="xMaxYMin slice" viewBox="0 0 400000 522"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">C</span></span></span></span></span></span>
<p>for a type of keys <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">K</span></span></span></span></span>, of messages <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">M</span></span></span></span></span>, and ciphertexts <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">C</span></span></span></span></span>,
along with a deterministic function:</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>:</mo><mi>K</mi><mo>⊗</mo><mi>C</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">D : K \otimes C \to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">M</span></span></span></span></span></span>
<p>We require the following correctness property of an encryption scheme:

<img src=../Images/a88ec8d5280d193df59d183ac5a60522c7b6cea44c73ed8bfadba948002d9eba.png alt= />
In other words, if we use the same key to encrypt and decrypt
many messages, we get the same messages out that we put in:
we can recover messages through decryption.</p>
<h2>Indistinguishability</h2>
<p>Informally, the security of encryption says that "no information"
can be extract from a ciphertext.
Formally, we model this via the property <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND-CPA</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND-CPA}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/f8ab8809150be50712b922f3f12444aed2615034bfabea9a0bf7dfc0d4222ee1.png alt= />
This says that one can't tell the difference between decryptiong
one set of messages (on the top), or another set of messages
(on the bottom).
This means that no information about the messages leaks through the ciphertexts.</p>
<p>Often we refer to the property <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND-CPA</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND-CPA}(1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span>
as <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose">]</span></span></span></span></span>.
Achieving the latter is much easier than achieving
the former for arbitrary <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span>,
as we'll see later.</p>
<h3>Left or Right vs Real or Random</h3>
<p>Another variant of security for encryption involves
comparing the encryption of a chosen set of messages,
and that of a random set of messages, as described by the property
<code>$\Pi[\text{\\$</code>IND-CPA}(N)]$:

<img src=../Images/157dfcfe008d15d674d70435d22201c450d5f74af9dd3df922b59743dad5f733.png alt= /></p>
<p>This turns out to be equivalent.</p>
<p>The first direction is trivial:
<strong>Claim:</strong></p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND-CPA</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>$IND-CPA</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND-CPA}(N)] \multimap \Pi[\text{\$IND-CPA}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">$</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></span>
<p><strong>Proof:</strong>

<img src=../Images/732c5e1891630c7aae7b2e913af3263292742b819b9421204a68bee946e1fd7d.png alt= />
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
<p>The second direction is a bit less trivial,
in that we need to use the assumption twice.</p>
<p><strong>Claim:</strong></p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>$IND-CPA</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND-CPA</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{\$IND-CPA}(N)]^2 \multimap \Pi[\text{IND-CPA}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1.1141em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">$</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></span>
<p><strong>Proof:</strong>

<img src=../Images/b3d9ac7573258b7e33e85ccaa3cbc462faa81835d625a8e20b85f8364bbbcd7c.png alt= />
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
<p>Because of this, we'll often use one of these properties as is more
convenient, since the difference between them doesn't really matter.</p>
<h2>One-Time Pad</h2>
<p>Now, we construct an example of a scheme that satisfies
the <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose">]</span></span></span></span></span> property.</p>
<p>To do so, we introduce the notion of a "binary" type.
This is a large type <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>, along with an operation
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo><mo>:</mo><mi>X</mi><mo>⊗</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\oplus : X \otimes X \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.6667em;"></span><span class="mord">⊕</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>,
and an element <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 : X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>, satisfying the following properties:

<img src=../Images/aa3f30f8ec2120d54cd43dcd51566f48cfe688785a4575cccfc4b0988f9e5099.png alt= /></p>
<p>An example of this would be some set of binary strings <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mi>λ</mi></msup></mrow><annotation encoding="application/x-tex">\{0, 1\}^\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1.0991em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">λ</span></span></span></span></span></span></span></span></span></span></span></span>,
with the usual xor operation.
The rules above just say that <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.6667em;"></span><span class="mord">⊕</span></span></span></span></span> is an associative and commutative
operator, with the extra property
that any element <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span></span> itself is the identity.
Also, we have a property related to randomness,
which says that xoring a random value with any other value results
in a random value.</p>
<p>This property is precisely what we'll use to make an encryption scheme.
The idea is that our keys, messages, and ciphertexts
will all be of type <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span>, and we encrypt a message by xoring it with a key.</p>
<p>We can check that this satisfies the correctness property for encryption:

<img src=../Images/ba92d104f56080427ea3c876f5ec9c6855e6e5183d60c46737927e7ce5fc899e.png alt= />
Furthermore, this is secure against a single query:

<img src=../Images/a6ab58c147a012382a87333e5e25ec79dbf2565d6f6e9328805ed77110ec6a9c.png alt= /></p>
<p>Against multiple queries, we do run into a problem though.
Intuitively, with multiple ciphertexts, we can calculate
the xor of two messages:

<img src=../Images/ae895319b7d47b24650726a03d929df817de00131e8c375c928c3718eab89e2c.png alt= />
This obviously leaks information about the underlying messages,
which is not good.</p>
<h2>Deterministic Schemes aren't IND-CPA Secure</h2>
<p>We can generalize the issue at hand, and show that any deterministic
encryption scheme will fail to be secure against multiple
encryption queries.</p>
<p>A deterministic process satisfies the following property:

<img src=../Images/82e885b2ff0adca40edfd588d3733a7162b92eb43b199a14280762ec03c64255.png alt= />
Note that for a randomized process, like $, this won't
be the case.
Generating a random value and then copying it
is not the same as generating two random values.</p>
<p>In the case of encryption, a deterministic scheme (relative to a fixed key)
will then satisfy this property like so:

<img src=../Images/dfca9bdec74c13b3800ac9531e9b76e4ed092bbdc50bfe1b165cf27aeb346c21.png alt= /></p>
<p>Now, let's say that we have two messages <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><msup><mi>m</mi><mo rspace="0em" lspace="0em" mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">m, m&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.9463em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> such that they result
in different ciphertexts (for xor, <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">≠</mi><msup><mi>m</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">m \neq m&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.1944em;height:0.8889em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="vertical-align:-0.1944em;height:0.8889em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> suffices):

<img src=../Images/de253d8dbd91fe238c3fbe84be37644c13af77272d793aa6e64e52975c933fed.png alt= /></p>
<p>We can then use that to show that the two processes
in <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND-CPA</mtext><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND-CPA}(2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span><span class="mord">-</span><span class="mord">C</span><span class="mord">P</span><span class="mord">A</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)]</span></span></span></span></span> are different.
This property claims the following equality:

<img src=../Images/de6cebb6bfb0669038e1b378a0a32cd46cc1e66cdb8e18ddd378b44d77a8b490.png alt= /></p>
<p>Now, consider the following "strategy" wrapped around the
black box shape of this property:

<img src=../Images/a569c51b1a94d1dd6bd716d86aa61320807719a1dc7b5b768785855bd53f1b6c.png alt= />
In other words, the first pair consists of identical messages,
and the last pair are two messages which will produce
two different ciphertexts.</p>
<p>If we have the left side of the property,
this becomes:

<img src=../Images/afdae3257e27029fa4e70139c58fa5f422e64566fb0c7cfe1a935afb284cf298.png alt= />
Crucially, we used the fact that encryption was deterministic,
in order to move it "behind the copy",
thus realizing that the output will be equal.
In other words, deterministic encryption will produce
identical ciphertexts on identical inputs.</p>
<p>On the right side of the property,
we use the second pair, which by assumption
will produce inequal ciphertexts, giving us:

<img src=../Images/8b1d69bfd8e548c1fc141b38e6a25fbb3da48ee66eb1e1313282a55f19ac3a9f.png alt= /></p>
<p>Now, since <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> and <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span> are not equal as processes,
this property cannot hold, at least for deterministic encryption schemes.</p>
<h1>Achieiving Multiple Encryptions</h1>
<p>Now, we move our attention to actually fixing this issue,
and achieving security against multiple encryption queries.
The approach we'll use here is actually a bit clever.
If you were to take a scheme that's secure against one encryption query,
then that would imply that it would be secure against many queries,
as long as you could use a new key each time (we'll prove this later).
Now, we could try generating a fresh key each time,
the issue is that the decryption algorithm only has access
to the original key, and the ciphertext,
and thus would not have access to this fresh key,
breaking the correctness of our scheme.</p>
<p>We can fix this by somehow being able to "hide" the fresh key
inside of the ciphertext, such that the information the decryption
scheme has will be enough to recover it.</p>
<h2>Pseudo-Random Functions</h2>
<p>This is where pseudo-random functions, or PRFs, come in.
The idea is that a PRF is a deterministic algorithm taking
in a secret key, but which behaves identically to a random function,
if you don't know the key.
This allows us to solve our conundrum:
we can place a unique value, called a nonce, inside each ciphertext
(for example, by generating it at random),
which will then make the output of the PRF effectively random,
thus providing a fresh key to use for encryption.</p>
<h3>A Formal Definition</h3>
<p>More formally, a PRF from <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span></span></span></span></span> to <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span></span></span></span></span> is a deterministic function <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>K</mi><mo>⊗</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">F : K \otimes X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.1389em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.0833em;height:0.7667em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0785em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.2222em;">Y</span></span></span></span></span>, over a type of key <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0715em;">K</span></span></span></span></span>.</p>
<p>The security property of a PRF is quite simple, namely that
it behaves like a random function if the key is selected
at random and not revealed, as described by <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>PRF</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{PRF}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">P</span><span class="mord">R</span><span class="mord">F</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/854ebfbb80273a869eba0f3859dffc9d3f7c4392a2cb098bae50c83f78f396d3.png alt= />
(Note that, crucially, we're using the same key for all queries,
using a different key for each query would make this trivial).</p>
<h2>IND-CPA Encryption from PRFs</h2>
<p>Next, we follow the roadmap we sketched above to construct
an IND-CPA secure encryption scheme from an IND secure scheme.</p>
<p>First, we consider the property <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Multi-IND</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{Multi-IND}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">-</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span>:

<img src=../Images/c4d7b83d28cf8153bb10661a366eea085509e91d0a53ad8ecbee4005c5a7a89c.png alt= /></p>
<p>This property follows in a natural way from the single key case:</p>
<p><strong>Claim:</strong></p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><msup><mo stretchy="false">]</mo><mi>N</mi></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Multi-IND</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND}]^N \multimap \Pi[\text{Multi-IND}(N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="margin-right:0.05em;top:-3.113em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">-</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></span>
<p><strong>Proof:</strong></p>
<p>By induction.</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><mo stretchy="false">]</mo><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Multi-IND</mtext><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND}] \multimap \Pi[\text{Multi-IND}(1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">-</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></span></span>
<p>trivially, since both properties are the same.</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><mo stretchy="false">]</mo><mo>⊗</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>IND</mtext><msup><mo stretchy="false">]</mo><mi>N</mi></msup><mo>⊸</mo><mi mathvariant="normal">Π</mi><mo stretchy="false">[</mo><mtext>Multi-IND</mtext><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi[\text{IND}] \otimes \Pi[\text{IND}]^N \multimap \Pi[\text{Multi-IND}(1 + N)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.109em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord">Π</span><span class="mopen">[</span><span class="mord text"><span class="mord">M</span><span class="mord">u</span><span class="mord">l</span><span class="mord">t</span><span class="mord">i</span><span class="mord">-</span><span class="mord">I</span><span class="mord">N</span><span class="mord">D</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)]</span></span></span></span></span></span>
<p>
<img src=../Images/ab2d29e8bb3c67b35d849897aad51e586e2138c0cb4da5ee633e8afc96751bb1.png alt= />
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
<p>(This is a specific case of a general theorem saying that
<span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>=</mo><mi>B</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo>⊸</mo><msup><mi>A</mi><mi>n</mi></msup><mo>=</mo><msup><mi>B</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">(A = B)^n \multimap A^n = B^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊸</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="margin-right:0.05em;top:-3.063em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0502em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>.)</p>
<p>Now, given an encryption scheme</p><pre><code>$$E : K_0 \otimes M \to C
$$,
and a PRF$$</code></pre>
<p>F : K_1 \otimes X \to K_0</p><span class="katex-wrapper"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo separator="true">,</mo><mi>w</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">, we construct an encryption scheme</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0269em;">w</span><span class="mord mathnormal">eco</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.0278em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">an</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.0359em;">cry</span><span class="mord mathnormal">pt</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">sc</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span></span></span>
<p>E' : K_1 \otimes M \to (X \otimes C)</p><pre><code>$$
The idea is that $X$ will be the type of our "nonce", which will be generated
at random and appended to the ciphertext:
![](../Images/37625f491629ee40ea1f9983a38d8dc3fec141456df8204238fd11ea11e5a5a4.png)
We also use the PRF to generate a fresh key from this nonce.

We can see that this encryption scheme is correct,
using the fact that $F$ is deterministic:
![](../Images/f829634d03c1c43ed2d00d136db44ba7d455f638498488c4286800e95d97fdbb.png)

All that's left is to prove that this scheme is secure.

**Claim:**:
$$</code></pre>
<p>\Pi[\text{PRF}(N)]^2 \otimes \Pi[\rho\text{RAND}(N)]^2 \otimes \Pi[\text{Multi-IND}(N)] \multimap \Pi[\text{IND-CPA}(N)]</p><pre><code>$$**Proof:**

![](../Images/0ff1d828983228ba8ff4961a39d7d3204719df1c4137df6c35773efbe801b376.png)
Then work backwards, applying $\epsilon_1$ then $\epsilon_0$
to reach the goal.

$\blacksquare$

# Public-Key Encryption

Next, we move from symmetric encryption to public key encryption.

In symmetric encryption, encryption and decryption use the same key,
which must be kept secret.

In public key encryption, encryption and decryption use different keys.
Encryption only requires a public key, which, as the name suggests,
can be public, whereas
decryption requires a secret key (and sometimes also the public key),
which must be kept secret.

This allows anyone to encrypt messages to a recipient,
but only for that recipient to decrypt messages sent to them.

More formally, a public key encryption scheme consists of:

- Types for public keys $\text{PK}$, private keys $\text{SK}$,
messages $M$, and ciphertexts $C$.
- A key generation algorithm $K : \emptyset \xrightarrow{\\$} (\text{SK}, \text{PK})$
- An encryption algorithm $E : \text{PK} \otimes M \xrightarrow{\\$} C$.
- An encryption algorithm $D : \text{SK} \otimes C \to M$.

The following correctness property must be satisfied:
(This is analogous to the case of symmetric encryption.)
![](../Images/e3ffdb9b1da0efdcb250bc06d44b57cab528d3fdf3c3aee06bf91004b9affbf4.png)

The security property is similar to that of symmetric key encryption,
except that the public key is also leaked:
![](../Images/036b44e17e593ee5f54c15c6cd6e3884f39ec256de96fd489c93446a1dcb258f.png)

Now, in this setup, we allow multiple queries.
But, it turns out that it's equivalent to allow just one query,
as we can show by induction:
![](../Images/25b10f9c930793731fdb532ad5849bfffebf8c6adad4fd24088a5c716c260c28.png)

Thus, we only consider the single query variant of this property,
which we define as $\Pi[\text{PK-IND}]$.

## KEM-DEM paradigm

A common way of constructing public key encryption schemes
for large messages is to first use a public key encryption
scheme to send a key, and then to use that key to encrypt
a large message with a symmetric encryption scheme.

There are usually two reasons to do this:
- Setups for public key encryption usually can't handle large messages.
- Even if they can, public key operations are much slower than symmetric ones.

If you only need to transmit a key to another party, rather than
being able to encrypt arbitrary messages to a public key,
then you can use a slightly weaker primitive, called a *key encapsulation
mechanism*, or KEM.

### KEMs

Formally, a KEM consists of:
- Types $\text{PK}$ (public keys), $\text{SK}$ (private keys), $\text{C}$
(ciphertexts / encapsulations), $\text{K}$ (output keys).
- A key generation algorithm $K : \emptyset \xrightarrow{\\$} (\text{SK}, \text{PK})$
- An encapsulation algorithm $E : \text{PK} \xrightarrow{\\$} C \otimes K$.
- A decapsulation algorithm $D : \text{SK} \otimes C \to K$.

The idea is that the encapsulation algorithm will generate a new key,
along with an encapsulation that hides it.
Then, the secret key allows one to recover the key inside an encapsulation.
For correctness, we require that the key we get when encapsulating
and decapsulating match, or, in other words, that swapping
them doesn't matter:
![](../Images/86f4211b74591887c3d7ed6daed8fb1473dbb929f93b62cf11de69e16d3629eb.png)

For security, we have a similar notion as that of public key encryption.
Instead of a "left vs right" notion, we instead use one of "real vs random".
Using a random key instead of the one produced in encapsulation
yields an equivalent process.
This is formally defined in the property $\Pi[\text{KEM-IND}]$:
![](../Images/8a3616dda36ebf48224fcb3ccbad5fdc8fbbf230d3f2e42b7c69e6288072016f.png)

#### Public-Key Encryption is a KEM

One obvious way to make a KEM is to generate a random key,
and then encrypt it with a public key encryption scheme:
![](../Images/14e528169d321069297b50ff30b5016e15063369723312b81a81f66a66a598da.png)

We can easily check that this satisfies the correctness property,
assuming the underlying public key encryption scheme does:
![](../Images/bc0649c43376b8c1cd61b310ac7865f556a43aa97130af2307aff6838a02361f.png)

Furthermore, security is also simple to check:
![](../Images/c219659294b89e1208c961246c56154c519bc804ddc593101a4589d5cb2d2b5e.png)

### KEM + Encryption = Public Key Encryption

The next thing we show is that one can combine a
KEM and a symmetric encryption scheme,
in order to get a public key encryption scheme.
We write $E_p$ and $D_p$ for the kem, and $E_s$ and $D_s$ for the symmetric
encryption scheme, and then define the following PKE scheme:
![](../Images/8904ef80d34d9b289e30834c4dbd3567399ea99c4d4dbb9d85e26e059765db1a.png)
We support the same messages as the symmetric encryption scheme,
and our ciphertexts are a combination of an encapsulated key,
and a symmetric ciphertext.

We can check that this scheme is correct, assuming
the underlying KEM and symmetric encryption scheme are:
![](../Images/9da4ea93fa24a3fd490065caa00fa6be0a6bf7da7d9381050f85749201b23c9d.png)

Next, we prove that this scheme also inherits the security
of the underlying primitives it's made up of:

**Claim:**$$</code></pre>
<p>\Pi[\text{KEM-IND}]^2 \otimes \Pi[\text{IND}] \multimap \Pi[\text{PK-IND}]</p><pre><code>$$**Proof:**
![](../Images/7566cdb8b0fbd0ebbf086d3e38eab389ba1ed2955bc5b3e92aafff587feb5a1c.png)

$\blacksquare$

With that, we now have a somewhat simplifies recipe to construct
public key encryption: just construct a KEM,
and then use any IND-secure encryption scheme,
such as a one-time pad.

# KEMs from Group Assumptions

In this section, we construct the underlying KEM
used in ElGamal encryption.
The underlying cryptographic assumption we use
is related to the hardness of the discrete logarithm
in a finite group, such as the group of points on an Elliptic Curve.
This is a very common and practical scheme.

## Groups

Before we get to hardness assumptions, we need to define
the basic group structure we'll be working with in this section:
i.e. the "cryptographic group".

A cryptographic group consists of:
- a type of scalars $\mathbb{F}$,
- a type of group elements $\mathbb{G}$,
- a distinguished point $G \in \mathbb{G}$,
- operators $+, \cdot : \mathbb{F}^2 \to \mathbb{F}$,
- an operator $+ : \mathbb{G}^2 \to \mathbb{G}$,
- an operator $* : \mathbb{F} \otimes \mathbb{G} \to \mathbb{G}$.

Furthermore, these need to satisfy the following properties:
![](../Images/30af52fda634eb769f7bb79f731a5956c25dcc3d2eb5c4a3944740d8a020c321.png)
For the algebraically inclined, these all stem from
assuming that $\mathbb{F}$ is a field, and $\mathbb{G}$
is an $\mathbb{F}$-vector space.


## DLog Assumption

Where things get interesting, from a cryptographic point of view,
is when we start adding hardness assumptions on top of
these basic operations.

A fundamental hardness assumption is that it's difficult
to compute discrete logarithms in the group.
In other words, given a group element,
it's difficult to figure out the scalar element required
to reach that element from the generator, via $*$.

Formally, the property $\Pi[\text{DLOG}]$ holds:
![](../Images/d2a9a721b2fd366d2493807b4ea1056bd9e1af349fb50dd688f9a8d6b1a777c8.png)
This tries to capture the intuition above,
showing that even with multiple guesses, the result will still always
be 0.

## CDH Assumption

We'll be needing a stronger assumption, namely
that of the "Computational Diffie Hellman" problem, or "CDH".
This says that given $A = a * G, B = b * G$, it's difficult
to compute $C = a \cdot b * G$.

More formally, the assumption is characterized by the following property,
$\Pi[\text{CDH}]$:
![](../Images/1bdbdba9563b1d696ddf35ca5be8689815c4b2377c2768cf1b01d014f27a962c.png)

As to why this assumption is useful, the beauty of the synthetic
approach is that you can just sort of observe how it gets used,
and thus see why it's useful.
In other words, it's useful cause you can use it.

## ElGamal KEM

Next, we construct a KEM whose security will be linked to this assumption.

The secret key will be a scalar in $\mathbb{F}$,
the public key a value in $\mathbb{G}$,
and the encapsulated key a value in $\mathbb{G}$.
We also assume a hash function $H : \mathbb{G} \to K$,
mapping group elements into symmetric keys.
We'll see how we model the security of this function later,
for now, when looking at correctness,
we just need to know that it's a deterministic function.

The crux of this scheme will come from the fact that:$$</code></pre>
<p>ab * G = a * (b * G) = b * (a * G)</p><pre><code>$$
We'll have $a * G$ as our public key, and $b * G$ as our encapsulation,
with $H(ab * G)$ as the secret.
This allows the holder of $a$ to calculate the secret from the encapsulated
value.

In more detail, let's define the algorithms for our KEM:
![](../Images/b93c638a0ffe3902dd1fe54c8de20218fa98c0dec52eaccaf1d9bccb4a1cf4e4.png)

At this point, we can go ahead and check the correctness of this construction:
![](../Images/de7fd5917013f8ec3d3565b4777d78ef3511d433cd602f623f93cb2e2e846761.png)
(After this point, we can swap after the copy,
and then repeat the argument backwards).
We only used the fact that $H$ was deterministic here,
but for security, we'll need to assume more about it.

## Random-Oracle Model

What we'll be doing is modelling $H$ as a random function.
Just replacing $H$ with $\rho$ isn't a great model though,
since it's possible to call $H$ in other contexts,
and get the same results as one does inside of this KEM,
because $H$ is just a deterministic algorithm.

In order to model the ability of "other parts" to also have
access to $H$, we will modify our games to also allow queries
to $H$.

Diagramatically, a process using a hash function $H$ will be modeled as:
![](../Images/f026938127b33319c021e2d7bb99021c72963a9a56d78551f76ce8c25614ae3c.png)
This allows composing such processes together while having them use
"the same" hash function.

This is called the "random oracle model" of security for processes
using hash functions.

## Proving Security

With this in hand, we can prove the security of our group-based
KEM in this model.

**Claim:**
In the random oracle model, it holds that:$$</code></pre>
<p>\Pi[\text{CDH}]^2 \multimap \Pi[\text{KEM-IND}]</p><pre><code>$$**Proof:**
![](../Images/42cb181146985c6174c3575bd1107dc70a281eaf57e3f9d4d79551a24f206ed3.png)
Then apply the same arguments in reverse, with those
two outputs swapped.

$\blacksquare$

# Conclusion

Hopefully this post gave you a taste of some of the kinds of arguments
this graphical syntax enables.
I've also restrained myself from trying to give a precise semantics
for the string diagrams in this post,
mainly because I haven't yet figured out those semantics,
but also because I think the "synthetic" style,
where you avoid a concrete semantics, working in a free category,
is the best one for most work.

As the post went on, I tried to put more and more weight
on the graphical reasoning, as opposed to words, trying to show
a bit of the extremes you can get if you really embrace it.
Hopefully I didn't lose you there.

I expect there to be more posts in this style as I flesh
out the details, and talk about various minutiae in the formalization.

# References

[^PZ23]

[^PZ23]: [[PZ23] An Introduction to String Diagrams for Computer Scientists](https://arxiv.org/abs/2305.08768)$$</code></pre><section class="footnotes">
<ol>
</ol>
</section>


</body>
</html>