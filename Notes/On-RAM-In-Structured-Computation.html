<!DOCTYPE html>
<html lang="en">
<head>
<title>cronokirby - On RAM In Structured Computation</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous"><title>cronokirby - On RAM In Structured Computation</title>

<link rel="stylesheet" href="/static/index.css">
<link rel="icon" href="/static/icon.png">
<script src="/static/theme.js" defer></script>
</head>
<body>
<header>
<div class="icon-bar">
  <a href="/">
    <img src="/static/icon.png" class="avatar" />
  </a>
  <button class="theme-toggle" id="theme-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" height="2em" viewBox="0 -960 960 960" width="2em" fill="currentColor"><path d="M480-120q-133 0-226.5-92.5T160-436q0-66 25-122t69-100l226-222 226 222q44 44 69 100t25 122q0 131-93.5 223.5T480-120Zm0-80v-568L310-600q-35 33-52.5 74.5T240-436q0 97 70 166.5T480-200Z"/></svg>
  </button>
</div>
<time datetime="2022-08-24">2022-08-24</time>

<h1>On RAM In Structured Computation</h1>




</header>

<p>An idea for encoding random access memory in structured computation as in
STARK arithmetization, or more general algebraic automata.</p><!--more-->
<p>If you look at the <a href=https://maticnetwork.github.io/miden/design/chiplets/memory.html>memory access design in MidenVM</a>, then you notice
that they have this interesting constraint of needing memory accesses
to have increasing addresses.</p>
<p>This is thus more like "linear access memory" than "random access memory".</p>
<p>There are two interesting aspects of their approach though:</p>
<ol><li>Computation is encoded with a VM, which hashes the instructions it processes.</li><li>For memory accesses, they keep a log of each memory operation.</li></ol>
<p>The log approach for memory allows relatively straight forward compilation
to circuits:</p>
<ol><li>With a time-sorted memory log, replace each read to memory with an access in
the private log, and each write with a constraint check to the private log.</li><li>With an access-sorted memory log, prove that the log is consistent,
in that when the values read come from the latest write, etc.</li><li>Prove that you know a permutation such that the access-sorted log permutes
to the time-sorted log.</li></ol>
<p>For 3., you can efficiently encode a permutation of a log of size <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.109em;">N</span></span></span></span></span> with <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N lg N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="vertical-align:-0.25em;height:1em;"></span><span class="mord mathnormal" style="margin-right:0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0197em;">Nl</span><span class="mord mathnormal" style="margin-right:0.0359em;">g</span><span class="mord mathnormal" style="margin-right:0.109em;">N</span><span class="mclose">)</span></span></span></span></span> gates,
using a routing network, so this can be done efficiently.</p>
<p>But this yields a circuit, which may not have the structured format
we need for, e.g. STARKs.</p>
<p>To get around this, we encode the computations in step 2. and 3. with
instructions for a VM, like with the MidenVM approach.</p>
<p>Linking this with step 1. is tricky though.
Basically, we need to make sure that the time-sorted log we work with
in the checking step is the same as was referenced in the "normal" computation.</p>
<p>One way to do this is for the normal computation to <em>hash</em> each entry
in the log as it uses them.</p>
<p>Then you also compute this hash when checking log integrity after sorting.</p>
<h3>Summary</h3>
<p>To summarize, here's an approach for supporting random access memory in
STARK-like automaton encodings of computation:</p>
<ol><li>You work with a VM architecture, like with Miden, or other ZK VMs.</li><li>In your bytecode, compute the hash of the memory operations you do as
they get processed, creating a hash <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0813em;">H</span></span></span></span></span>.</li><li>Using bytecode without memory operations, compute the following steps:</li><li>Check that a private log, sorted by address, is consistent (reads use the most recent value written, etc.).</li><li>Check that a private permutation maps this log to another one whose
hash is <span class="katex-wrapper"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0813em;">H</span></span></span></span></span>.</li></ol>
<p>Checking that permutation in a small amount of space is tricky, but
most likely doable given the ability to reference a private input
by index in your bytecode.</p><section class="footnotes">
<ol>
</ol>
</section>


</body>
</html>